<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wei&#39;s Blog</title>
    <description>Wei Zepeng&#39;s Blog.</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 21 Apr 2016 17:18:01 +0800</pubDate>
    <lastBuildDate>Thu, 21 Apr 2016 17:18:01 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>My BigShow Plan</title>
        <description>&lt;p&gt;关于BigShow, 最重要的是：快！快！快！&lt;/p&gt;

&lt;p&gt;但是我最近确实做慢了。&lt;/p&gt;

&lt;p&gt;应该反思。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;任务300&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;保存数据&lt;/li&gt;
  &lt;li&gt;点击搜索后的第一次自动搜索提示&lt;/li&gt;
  &lt;li&gt;搜索界面的网格视图&lt;/li&gt;
  &lt;li&gt;搜索框的输入与确定&lt;/li&gt;
  &lt;li&gt;搜索框的下拉提示列表&lt;/li&gt;
  &lt;li&gt;选择图片后的图片展示&lt;/li&gt;
  &lt;li&gt;关于网格的第一条Item √&lt;/li&gt;
  &lt;li&gt;关于网格的第后面的Item √&lt;/li&gt;
  &lt;li&gt;关于网格的数据Model √&lt;/li&gt;
  &lt;li&gt;网格图中的划线 √&lt;/li&gt;
  &lt;li&gt;网格图中的右上角数字&lt;/li&gt;
  &lt;li&gt;网格图中的数字操作&lt;/li&gt;
  &lt;li&gt;网格图的点击跳转效果&lt;/li&gt;
  &lt;li&gt;网格图的第一次显示效果&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;翻卷特效&lt;/h2&gt;

&lt;p&gt;https://github.com/harism/android_page_curl
https://github.com/suyonoion/PageCurl_BookView&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;首先是36Kr的一篇文章, 可以借助这个GIF搜索引擎：http://giphy.com/&lt;/p&gt;

&lt;p&gt;微软的Bing也是可以搜索gif图片，但我发现它的图片还是来自Giphy.&lt;/p&gt;

&lt;p&gt;比如搜索南方公园 http://giphy.com/search/south-park&lt;/p&gt;

&lt;p&gt;所以，BigShow的内容方面就有源源不断与时俱进的素材了。&lt;/p&gt;

&lt;p&gt;这里是 Giphy 的文档：https://github.com/Giphy/GiphyAPI&lt;/p&gt;

&lt;p&gt;更多的文档：https://api.giphy.com/  http://giphy.com/labs&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;内容分级&lt;/h2&gt;

&lt;p&gt;关于Parameters,
rating - limit results to those rated (y,g, pg, pg-13 or r).&lt;br /&gt;
  G: General Audiences. All ages admitted.&lt;br /&gt;
  PG: Parental Guidance Suggested. Some material may not be suitable for children.&lt;br /&gt;
  PG-13: Parents Strongly Cautioned. Some material may be inappropriate for children under 13.&lt;br /&gt;
  R: Restricted. Under 17 requires accompanying parent or adult guardian.&lt;br /&gt;
  NC-17: No Children. No one 17 and under admitted.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;选择不光可以是文字，它可以是任何东西。
————————————————————————————————-&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;数据&lt;/h2&gt;

&lt;p&gt;Plot
num(二叉树排序)&lt;br /&gt;
isEnd: 0 非End, 1 End&lt;br /&gt;
dataFrom: (参考项)giphy, user&lt;br /&gt;
dataImg: (jsonstring: data: type:)&lt;br /&gt;
dataText: (jsonstring: data: type:)&lt;br /&gt;
dataChoose: (jsonstring: data: type:)&lt;br /&gt;
fromStory&lt;/p&gt;

&lt;p&gt;Story
[nothing add now]&lt;/p&gt;

&lt;p&gt;关于GiphyAPI&lt;/p&gt;

&lt;p&gt;Translate Endpoint:&lt;br /&gt;
http://api.giphy.com/v1/gifs/translate?s=superman&amp;amp;api_key=dc6zaTOxFJmzC&lt;br /&gt;
将名词转化为特定图片,每次随机一个&lt;/p&gt;

&lt;p&gt;Search Endpoint: &lt;br /&gt;
http://api.giphy.com/v1/gifs/search?q=funny+cat&amp;amp;api_key=dc6zaTOxFJmzC&lt;br /&gt;
通过搜索关键字获得数据列表,默认为25个&lt;/p&gt;

&lt;p&gt;Random Endpoint:&lt;br /&gt;
http://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC&amp;amp;tag=american+psycho&lt;br /&gt;
根据标签随机获得一个数据&lt;/p&gt;

&lt;p&gt;Trending Gifs:&lt;br /&gt;
http://api.giphy.com/v1/gifs/trending?api_key=dc6zaTOxFJmzC&lt;br /&gt;
随机数据流25个&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Gmail之父说过一句话：你需要将某几件事情做得精益求精，而不要追求面面俱到。&lt;/p&gt;

&lt;p&gt;对于BigShow，有3个核心点：
制作：上手环节、自动补全
游戏中：选择、结局、生命值
分类：栏目、排序、推荐&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关于字体&lt;/p&gt;

&lt;p&gt;我在 http://www.uisdc.com/23-handwritten-english-font 找到了http://www.fontsquirrel.com/fonts/architects-daughter,
该ArchitectsDaughter.ttf字体遵从SIL Open Font License协议。
知乎上其他的 https://www.zhihu.com/question/21759657。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/18/my-bigshow-plan/</link>
        <guid isPermaLink="true">/2016/04/18/my-bigshow-plan/</guid>
        
        
        <category>Plan</category>
        
      </item>
    
      <item>
        <title>Android graphics的camera和matrix</title>
        <description>&lt;h2 id=&quot;android-graphicscameramatrix&quot;&gt;关于Android graphics的Camera和Matrix&lt;/h2&gt;

&lt;h3 id=&quot;camera&quot;&gt;Camera&lt;/h3&gt;

&lt;p&gt;这是camera类的主要方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public native void save();
public native void restore();
public native void translate(float x, float y, float z);
public native void rotateX(float deg);
public native void rotateY(float deg);
public native void rotateZ(float deg);
public native void rotate(float x, float y, float z);
public native float getLocationX();
public native float getLocationY();
public native float getLocationZ();
public native void setLocation(float x, float y, float z);
public void getMatrix(Matrix matrix) {
    nativeGetMatrix(matrix.native_instance);
}
public void applyToCanvas(Canvas canvas) {
    nativeApplyToCanvas(canvas.mNativeCanvas);
}
public native float dotWithNormal(float dx, float dy, float dz);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里是Camera变换的坐标轴
&lt;img src=&quot;/Users/tindle/Desktop/20150117092512161.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在rotate的时候，要站在该轴正方向的地方看，才能明白他的旋转。
如 camera.rotateZ(-60)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/tindle/Desktop/20150117092514165.png&quot; alt=&quot;&quot; /&gt;!&lt;/p&gt;

&lt;h3 id=&quot;matrix&quot;&gt;Matrix&lt;/h3&gt;

&lt;p&gt;Matrix是一个3 x 3的2D空间矩阵&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/tindle/Desktop/1349614431_7130.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MPERSP_2指的是投影变换,其实际作用就是如果MPERSP_2=0.5，那么物体是原来的4倍大小；如果MPERSP_2=2，那么物体是原来的1/4大小。&lt;/p&gt;

&lt;p&gt;Camera和Matrix的联合使用：一般情况下，如果我们需要进行3D变换，那么需要将Camera和Matrix联合使用，使用Camera进行x轴或y轴的旋转，使用Matrix进行平移或放大。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/10/android-graphics%E7%9A%84camera%E5%92%8Cmatrix/</link>
        <guid isPermaLink="true">/2016/03/10/android-graphics%E7%9A%84camera%E5%92%8Cmatrix/</guid>
        
        
      </item>
    
      <item>
        <title>关于RxJava的使用</title>
        <description>&lt;p&gt;RxJava 的观察者模式
RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。&lt;/p&gt;

&lt;p&gt;与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。&lt;/p&gt;

&lt;p&gt;1) 创建 Observer&lt;br /&gt;
Observer 即观察者&lt;/p&gt;

&lt;p&gt;Observer&lt;string&gt; observer = new Observer&lt;string&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}
 
@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Subscriber&lt;string&gt; subscriber = new Subscriber&lt;string&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}
 
@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;他们的基本使用方式是完全一样的&lt;/p&gt;

&lt;p&gt;2) 创建 Observable&lt;br /&gt;
Observable 即被观察者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Observable observable = Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {
@Override
public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber) {
    subscriber.onNext(&quot;Hello&quot;);
    subscriber.onNext(&quot;Hi&quot;);
    subscriber.onNext(&quot;Aloha&quot;);
    subscriber.onCompleted();
}});

Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();

String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面 just(T…) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。&lt;/p&gt;

&lt;p&gt;3) Subscribe (订阅)&lt;br /&gt;
创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;observable.subscribe(observer);
// 或者：
observable.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出Subscriber：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;() {
// onNext()
@Override
public void call(String s) {
    Log.d(tag, s);
}
};
Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;() {
// onError()
@Override
public void call(Throwable throwable) {
    // Error handling
}
};
Action0 onCompletedAction = new Action0() {
// onCompleted()
@Override
public void call() {
    Log.d(tag, &quot;completed&quot;);
}
};
 
// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 	onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 	onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, 	onCompletedAction);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;线程控制 —— Scheduler&lt;/p&gt;

&lt;p&gt;subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。
observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Observable.just(1, 2, 3, 4)
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Action1&amp;lt;Integer&amp;gt;() {
    @Override
    public void call(Integer number) {
        Log.d(tag, &quot;number:&quot; + number);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;变换&lt;/h3&gt;

&lt;p&gt;map(): 事件对象的直接变换，它是 RxJava 最常用的变换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
.map(new Func1&amp;lt;String, Bitmap&amp;gt;() {
    @Override
    public Bitmap call(String filePath) { // 参数类型 String
        return getBitmapFromPath(filePath); // 返回类型 Bitmap
    }
})
.subscribe(new Action1&amp;lt;Bitmap&amp;gt;() {
    @Override
    public void call(Bitmap bitmap) { // 参数类型 Bitmap
        showBitmap(bitmap);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;map() 是一对一的转化，而我现在的要求是一对多的转化, 就需要用 flatMap()了.&lt;/p&gt;

 	Student[] students = …;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Subscriber&amp;lt;Course&amp;gt; subscriber = new Subscriber&amp;lt;Course&amp;gt;() {
@Override
public void onNext(Course course) {
    Log.d(tag, course.getName());
}
...
};
Observable.from(students)
.flatMap(new Func1&amp;lt;Student, Observable&amp;lt;Course&amp;gt;&amp;gt;() {
    @Override
    public Observable&amp;lt;Course&amp;gt; call(Student student) {
        return Observable.from(student.getCourses());
    }
})
.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。通过 observeOn() 的多次调用，程序实现了线程的多次切换.&lt;/p&gt;

 	Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.subscribeOn(Schedulers.io())
.observeOn(Schedulers.newThread())
.map(mapOperator) // 新线程，由 observeOn() 指定
.observeOn(Schedulers.io())
.map(mapOperator2) // IO 线程，由 observeOn() 指定
.observeOn(AndroidSchedulers.mainThread) 
.subscribe(subscriber);  // Android 主线程，由 observeOn() 指定
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;至此，结束。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/05/%E5%85%B3%E4%BA%8Erxjava%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">/2016/03/05/%E5%85%B3%E4%BA%8Erxjava%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>关于StaticLayout和DynamicLayout</title>
        <description>&lt;p&gt;StaticLayout 来自 http://developer.android.com/reference/android/text/StaticLayout.html&lt;/p&gt;

&lt;p&gt;DynamicLayout 来自 http://developer.android.com/reference/android/text/DynamicLayout.html&lt;/p&gt;

&lt;h2 id=&quot;cerditsroll&quot;&gt;CerditsRoll&lt;/h2&gt;

&lt;p&gt;在该项目中，使用了一些&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Feb 2016 00:00:00 +0800</pubDate>
        <link>/2016/02/17/%E5%85%B3%E4%BA%8Estaticlayout%E5%92%8Cdynamiclayout/</link>
        <guid isPermaLink="true">/2016/02/17/%E5%85%B3%E4%BA%8Estaticlayout%E5%92%8Cdynamiclayout/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Screen Density</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;宽高计算&lt;/h1&gt;

&lt;p&gt;在Activity中，可以这样获得宽高密：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
	float mDensity = getBaseContext().getResources().getDisplayMetrics().density;
	float mScreenHeight = getBaseContext().getResources().getDisplayMetrics().heightPixels;
    float mScreenWidth = getBaseContext().getResources().getDisplayMetrics().widthPixels;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如，我的手机Nexus6手机的分辨率是 1440*2560，
打印出的数据是：
desity:3.5
height:2392.0
width:1440.0&lt;/p&gt;

&lt;p&gt;接下来，查看statusBar和navigationBar的高度：&lt;/p&gt;

&lt;p&gt;```
    //获取statusBar高度
    public int getStatusBarHeight(Context context){
        int result = 0;
        int resourceId = context.getResources().getIdentifier(“status_bar_height”, “dimen”, “android”);
        if(resourceId&amp;gt;0){
            result = context.getResources().getDimensionPixelSize(resourceId);
        }
        return result;
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取底部navigationBar高度
public int getNavigationBarHeight(Context context) {
    int result = 0;
    int resourceId = context.getResources().getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);
    if(resourceId&amp;gt;0){
        result = context.getResources().getDimensionPixelSize(resourceId);
    }
    return result;
} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印出的数据：
statusbar height:84
navigationbar height:168&lt;/p&gt;

&lt;p&gt;接下来计算：
168/3.5=48
2560-2392=168, 所以NavigationBar包括了StatusBar.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dp2px&quot;&gt;dp2px&lt;/h2&gt;

&lt;p&gt;实际，返回的值是 (int)(dp * density + 0.5f);&lt;/p&gt;

</description>
        <pubDate>Mon, 08 Feb 2016 19:59:05 +0800</pubDate>
        <link>/2016/02/08/screen-density/</link>
        <guid isPermaLink="true">/2016/02/08/screen-density/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>NSString Some Useful Methods</title>
        <description>&lt;p&gt;2015-11-26-NSString Some Useful Methods&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;[string substringToIndex:N]
 get substring from 0 to N-1;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[string substringFromIndex:N]
 get substring form N to length-1;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[string substringWithRange:NSMakeRange(N,M)]
 get substring from N to N+M-1;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;([string rangeOfString:@“A”].location == NSNotFound)
 check substring contains ‘A’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Get Range Of String
 ```
`NSString*string =@“abcdefgh”;
NSRange range = &lt;a href=&quot;&quot;&gt;string rangeOfString:@”fg”&lt;/a&gt;;
NSLog(@”rang:%@”,NSStringFromRange(range));//{5,2}
string = &lt;a href=&quot;&quot;&gt;string substringWithRange:range&lt;/a&gt;;
```
`&lt;/li&gt;
  &lt;li&gt;Separate String
```
`NSString*string =@“123A456”;
NSArray *array = &lt;a href=&quot;&quot;&gt;string componentsSeparatedByString:@”A”&lt;/a&gt;;
NSLog(@”array:%@”,array); 
```
`&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 26 Nov 2015 00:00:00 +0800</pubDate>
        <link>/2015/11/26/nsstring-some-useful-methods/</link>
        <guid isPermaLink="true">/2015/11/26/nsstring-some-useful-methods/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>SoftKeyBoard</title>
        <description>&lt;p&gt;iOS UITextView UITextField About SoftKeyBoard&lt;/p&gt;

&lt;p&gt;一、键盘风格   
UIKit框架支持8种风格键盘。
.	typedef enum   
.	    UIKeyboardTypeDefault,                // 默认键盘：支持所有字符   
.	    UIKeyboardTypeASCIICapable,           // 支持ASCII的默认键盘   
.	    UIKeyboardTypeNumbersAndPunctuation,  // 标准电话键盘，支持+*#等符号   
.	    UIKeyboardTypeURL,                    // URL键盘，有.com按钮；只支持URL字符   
.	    UIKeyboardTypeNumberPad,              //数字键盘   
.	    UIKeyboardTypePhonePad,               // 电话键盘   
.	    UIKeyboardTypeNamePhonePad,           // 电话键盘，也支持输入人名字   
.	    UIKeyboardTypeEmailAddress,           // 用于输入电子邮件地址的键盘   
.	} UIKeyboardType;  
用法用例：
textView.keyboardtype = UIKeyboardTypeNumberPad;&lt;/p&gt;

&lt;p&gt;二、键盘外观
.	typedef enum   
.	    UIKeyboardAppearanceDefault,    // 默认外观：浅灰色   
.	    UIKeyboardAppearanceAlert,      //深灰/石墨色   
.	} UIKeyboardAppearance;  
用法用例：
textView.keyboardAppearance=UIKeyboardAppearanceDefault;&lt;/p&gt;

&lt;p&gt;三、回车键
.	typedef enum   
.	    UIReturnKeyDefault,  //默认：灰色按钮，标有Return
.	    UIReturnKeyGo,  //标有Go的蓝色按钮
.	    UIReturnKeyGoogle,  //标有Google的蓝色按钮，用于搜索
.	    UIReturnKeyJoin,  //标有Join的蓝色按钮
.	    UIReturnKeyNext,  //标有Next的蓝色按钮
.	    UIReturnKeyRoute,  //标有Route的蓝色按钮
.	    UIReturnKeySearch,  //标有Search的蓝色按钮
.	    UIReturnKeySend,  //标有Send的蓝色按钮
.	    UIReturnKeyYahoo,  //标有Yahoo!的蓝色按钮，用于搜索
.	    UIReturnKeyDone,  //标有Done的蓝色按钮
.	    UIReturnKeyEmergencyCall,  //紧急呼叫按钮
.	} UIReturnKeyType;  
用法用例：
textView.returnKeyType=UIReturnKeyGo;&lt;/p&gt;

&lt;p&gt;四、自动大写
.	typedef enum   
.	    UITextAutocapitalizationTypeNone, //不自动大写   
.	    UITextAutocapitalizationTypeWords, //单词首字母大写   
.	    UITextAutocapitalizationTypeSentences, //句子首字母大写   
.	    UITextAutocapitalizationTypeAllCharacters, //所有字母大写   
.	} UITextAutocapitalizationType;  
用法用例：
textField.autocapitalizationType = UITextAutocapitalizationTypeWords;&lt;/p&gt;

&lt;p&gt;五、自动更正
.	typedef enum   
.	    UITextAutocorrectionTypeDefault,//默认   
.	    UITextAutocorrectionTypeNo,//不自动更正   
.	    UITextAutocorrectionTypeYes,//自动更正   
.	} UITextAutocorrectionType;  
用法用例：
textField.autocorrectionType = UITextAutocorrectionTypeYes;&lt;/p&gt;

&lt;p&gt;六、安全文本输入
textView.secureTextEntry=YES;
开启安全输入主要是用于密码或一些私人数据的输入，此时会禁用自动更正和自此缓存。&lt;/p&gt;

&lt;p&gt;统计字符：
1、UITextView
- (void)textViewDidChange:(UITextView *)textView&lt;/p&gt;

&lt;p&gt;int count = &lt;a href=&quot;#&quot;&gt;textView.text length&lt;/a&gt;;
//这里的count就是字符个数了
}&lt;/p&gt;

&lt;p&gt;2、UITextField
方法一：
自己先为UITextField的Editing Changed事件添加一个响应方法
-(IBAction)valuechange//m_TextField是UITextField的一个IBOutlet&lt;/p&gt;

&lt;p&gt;int count = &lt;a href=&quot;#&quot;&gt;m_TextField.text length&lt;/a&gt;;
 //count就是当前的字符个数
//下边是将字符限制在140以内
if (&lt;a href=&quot;#&quot;&gt;m_TextField.text length&lt;/a&gt;&amp;gt;140) 
[m_TextField setText:&lt;a href=&quot;#&quot;&gt;m_TextField.text substringToIndex:140&lt;/a&gt;];//多出140时，只取前140个字符
}
}&lt;/p&gt;

&lt;p&gt;方法二：
在代理方法：- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string，判断range.length的值来判断输入的是回格还是其它字符&lt;/p&gt;

&lt;p&gt;响应Return键：
1、UITextView
//代理方法
- (BOOL)textView:(UITextView &lt;em&gt;)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString &lt;/em&gt;)text&lt;/p&gt;

&lt;p&gt;if (1 == range.length) //按下回格键
return YES;
}
if (&lt;a href=&quot;#&quot;&gt;text isEqualToString:@”n”&lt;/a&gt;) //按下return键
//这里隐藏键盘，不做任何处理
&lt;a href=&quot;#&quot;&gt;textView resignFirstResponder&lt;/a&gt;;
return NO;
}else 
if (&lt;a href=&quot;#&quot;&gt;textView.text length&lt;/a&gt; &amp;lt; 140) //判断字符个数
return YES;
}&lt;br /&gt;
}
return NO;
}&lt;/p&gt;

&lt;p&gt;2、UITextField
这个直接有代理方法哈
- (BOOL)textFieldShouldReturn:(UITextField *)textField&lt;/p&gt;

&lt;p&gt;UITextField进入编辑状态 获得焦点 becomeFirstResponder
 关闭键盘 resignFirstResponder&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Sep 2015 22:06:05 +0800</pubDate>
        <link>/2015/09/25/about-ios-softkeyboard/</link>
        <guid isPermaLink="true">/2015/09/25/about-ios-softkeyboard/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>What I Use Git to Build Blog</title>
        <description>&lt;h1 id=&quot;what-i-use-git-to-build-blog&quot;&gt;What I Use Git to Build Blog&lt;/h1&gt;

&lt;p&gt;First git repository is empty.&lt;/p&gt;

&lt;p&gt;So we should first add and commit to init the master branch.&lt;/p&gt;

&lt;p&gt;After above, you could make a new branch.&lt;/p&gt;

&lt;p&gt;init a new branch&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git branch testing&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;show all branch&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git branch -a &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;check what status it is now&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git status &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This article is really detailed.
&lt;a href=&quot;http://blog.jobbole.com/25808/&quot;&gt;http://blog.jobbole.com/25808/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git checkout —orphan gh-pages &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git add . &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git commit -m &quot;first post&quot; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git remote add origin https://github.com/username/projectName.git &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git push origin gh-pages &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;—- Finally, I found it.
&lt;a href=&quot;http://tindlewei.github.io/WeiBlog/&quot;&gt;http://tindlewei.github.io/WeiBlog/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What Helped me. 
&lt;a href=&quot;http://www.aymerick.com/2014/07/22/jekyll-github-pages-bower-bootstrap.html&quot;&gt;http://www.aymerick.com/2014/07/22/jekyll-github-pages-bower-bootstrap.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Oops, I installed bower &lt;a href=&quot;https://github.com/bower/bower&quot;&gt;https://github.com/bower/bower&lt;/a&gt;
Also installed grunt &lt;a href=&quot;http://gruntjs.com/&quot;&gt;GRUNT&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Sep 2015 22:06:05 +0800</pubDate>
        <link>/2015/09/06/what-i-use-git-to-build-blog/</link>
        <guid isPermaLink="true">/2015/09/06/what-i-use-git-to-build-blog/</guid>
        
        
        <category>Jekyll</category>
        
      </item>
    
      <item>
        <title>How could I make a Jekyll website</title>
        <description>&lt;h1 id=&quot;how-could-i-make-a-jekyll-website&quot;&gt;How could I make a Jekyll website&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://octodex.github.com/images/minion.png&quot; alt=&quot;Minion&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com/docs/quickstart/&quot;&gt;http://jekyllrb.com/docs/quickstart/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/using-jekyll-with-pages/&quot;&gt;https://help.github.com/articles/using-jekyll-with-pages/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.html&quot;&gt;http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Sep 2015 22:06:05 +0800</pubDate>
        <link>/2015/09/06/how-could-i-make-a-jekyll-website/</link>
        <guid isPermaLink="true">/2015/09/06/how-could-i-make-a-jekyll-website/</guid>
        
        
        <category>Jekyll</category>
        
      </item>
    
      <item>
        <title>Lorem Ipsum</title>
        <description>&lt;h3 id=&quot;the-standard-lorem-ipsum-passage-used-since-the-1500s&quot;&gt;The standard Lorem Ipsum passage, used since the 1500s&lt;/h3&gt;

&lt;p&gt;“Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.”&lt;/p&gt;

&lt;h3 id=&quot;section-11032-of-de-finibus-bonorum-et-malorum-written-by-cicero-in-45-bc&quot;&gt;Section 1.10.32 of “de Finibus Bonorum et Malorum”, written by Cicero in 45 BC&lt;/h3&gt;

&lt;p&gt;“Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?”&lt;/p&gt;

&lt;h3 id=&quot;translation-by-h-rackham&quot;&gt;1914 translation by H. Rackham&lt;/h3&gt;

&lt;p&gt;“But I must explain to you how all this mistaken idea of denouncing pleasure and praising pain was born and I will give you a complete account of the system, and expound the actual teachings of the great explorer of the truth, the master-builder of human happiness. No one rejects, dislikes, or avoids pleasure itself, because it is pleasure, but because those who do not know how to pursue pleasure rationally encounter consequences that are extremely painful. Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but because occasionally circumstances occur in which toil and pain can procure him some great pleasure. To take a trivial example, which of us ever undertakes laborious physical exercise, except to obtain some advantage from it? But who has any right to find fault with a man who chooses to enjoy a pleasure that has no annoying consequences, or one who avoids a pain that produces no resultant pleasure?”&lt;/p&gt;

&lt;h3 id=&quot;section-11033-of-de-finibus-bonorum-et-malorum-written-by-cicero-in-45-bc&quot;&gt;Section 1.10.33 of “de Finibus Bonorum et Malorum”, written by Cicero in 45 BC&lt;/h3&gt;

&lt;p&gt;“At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio. Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil impedit quo minus id quod maxime placeat facere possimus, omnis voluptas assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates repudiandae sint et molestiae non recusandae. Itaque earum rerum hic tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias consequatur aut perferendis doloribus asperiores repellat.”&lt;/p&gt;

&lt;h3 id=&quot;translation-by-h-rackham-1&quot;&gt;1914 translation by H. Rackham&lt;/h3&gt;

&lt;p&gt;“On the other hand, we denounce with righteous indignation and dislike men who are so beguiled and demoralized by the charms of pleasure of the moment, so blinded by desire, that they cannot foresee the pain and trouble that are bound to ensue; and equal blame belongs to those who fail in their duty through weakness of will, which is the same as saying through shrinking from toil and pain. These cases are perfectly simple and easy to distinguish. In a free hour, when our power of choice is untrammelled and when nothing prevents our being able to do what we like best, every pleasure is to be welcomed and every pain avoided. But in certain circumstances and owing to the claims of duty or the obligations of business it will frequently occur that pleasures have to be repudiated and annoyances accepted. The wise man therefore always holds in these matters to this principle of selection: he rejects pleasures to secure other greater pleasures, or else he endures pains to avoid worse pains.”&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Sep 2015 22:06:05 +0800</pubDate>
        <link>/2015/09/06/lorem-ipsum/</link>
        <guid isPermaLink="true">/2015/09/06/lorem-ipsum/</guid>
        
        
        <category>Jekyll</category>
        
      </item>
    
  </channel>
</rss>
