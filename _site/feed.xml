<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wei&#39;s Blog</title>
    <description>Wei Zepeng&#39;s Blog.</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 Jul 2016 19:25:43 +0800</pubDate>
    <lastBuildDate>Mon, 04 Jul 2016 19:25:43 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>RxJava一些概念的理解</title>
        <description>&lt;p&gt;RxJava一些概念的理解 
(摘录自soaringEveryday的博客)&lt;/p&gt;

&lt;p&gt;api/students/getAll (传入班级的id获得班级的学生数组，返回值是list)
api/courses/getAll (传入Student的id获得这个学生所上的课程，返回值是List)&lt;/p&gt;

&lt;p&gt;使用Volley是下面这样子：&lt;/p&gt;

&lt;p&gt;```
private void getAllStudents(String id) {
        BaseRequest baseRequest = new BaseRequest();
        baseRequest.setClassId(id);
        String url = AppConfig.SERVER_URL + “api/students/getAll”;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    final GsonRequest request = new GsonRequest&amp;lt;&amp;gt;(url, baseRequest, Response.class, new Response.Listener&amp;lt;response&amp;gt;() {
        @Override
        public void onResponse(Response response) {
            if (response.getStatus() &amp;gt; 0) {
                List&amp;lt;student&amp;gt; studentList = response.getData();
                for (Student student : studentList) {

                }
            } else {
                //error
            }
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            //error
        }
    });
    MyVolley.startRequest(request);
}

private void getAllCourses(String id) {
    BaseRequest baseRequest = new BaseRequest();
    baseRequest.setStudentId(id);
    String url = AppConfig.SERVER_URL + &quot;api/courses/getAll&quot;;

    final GsonRequest request = new GsonRequest&amp;lt;&amp;gt;(url, baseRequest, Response.class, new Response.Listener&amp;lt;response&amp;gt;() {
        @Override
        public void onResponse(Response response) {
            if (response.getStatus() &amp;gt; 0) {
                List&amp;lt;course&amp;gt; courseList = response.getData();
                for (Course course : courseList) {
                    //use
                }
            } else {
                //error
            }
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            //error
        }
    });
    MyVolley.startRequest(request);
} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用RxJava是下面这样：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
ConnectionBase.getApiService2()
                .getStudents(101)
                .flatMap(new Func1&amp;lt;student, observable&amp;lt;course=&quot;&quot;&amp;gt;&amp;gt;() {
                    @Override
                    public Observable&amp;lt;course&amp;gt; call(Student student) {
                        return ConnectionBase.getApiService2().getAllCourse(student.getId());
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1&amp;lt;course&amp;gt;() {
                    @Override
                    public void call(Course course) {
                        //use the Course
                    }
                });
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先getStudent传入了班级id(101)返回了Observable，然后链式调用flatMap操作符对这个Observable进行变换处理，针对每一个发射出来的Student进行再次请求 ConnectionBase.getApiService2().getAllCourse从而返回Observable，最后对这个 ConnectionBase.getApiService2().getAllCourse进行订阅，即subscribe方法，再Action1这个闭包的回调中使用course。&lt;/p&gt;

&lt;p&gt;flatMap的作用就是对传入的对象进行处理，返回下一级所要的对象的Observable包装。&lt;/p&gt;

&lt;p&gt;FuncX和ActionX的区别。FuncX包装的是有返回值的方法，用于Observable的变换、组合等等；ActionX用于包装无返回值的方法，用于subscribe方法的闭包参数。Func1有两个入参，前者是原始的参数类型，后者是返回值类型；而Action1只有一个入参，就是传入的被消费的数据类型。&lt;/p&gt;

&lt;p&gt;subscribeOn(Schedulers.io()).observeOn(AndroidScheduler.mainThread())是最常用的方式，后台读取数据，主线程更新界面。subScribeOn指在哪个线程发射数据，observeOn是指在哪里消费数据。由于最终的Course要刷新界面，必须要在主线程上调用更新view的方法，所以observeOn(AndroidScheduler.mainThread())是至关重要的。&lt;/p&gt;

&lt;h1 id=&quot;map--flatmap&quot;&gt;map &amp;amp; flatMap&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
ConnectionBase.getApiService2()
                .getStudents(101)
                .map(new Func1&amp;lt;student, Course&amp;gt;() {
                    @Override
                    public Course call(Student student) {
                        return conventStudentToCourse();// has problem
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1&amp;lt;course&amp;gt;() {
                    @Override
                    public void call(Course course) {
                        //use the Course
                    }
                });
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到map也是接受一个Func1闭包，但是这个闭包的第二个参数即返回值参数类型并不是一个被包装的Observable，而是实际的原始类型，由于call的返回值是Course，所以conventStudentToCourse这里就不能用Retrofit2的方式返回一个Observable了。&lt;/p&gt;

&lt;p&gt;所以这里是有一个问题的，对于这种嵌套的网络请求，由于接到上端数据流到处理后将结果数据放入下端数据流是一个异步的过程，而conventStudentToCourse这种直接将Student转化为Course是没法做到异步的，因为没有回调方法。那么这种情况，最好还是用flatMap并通过retrofit的方式来获取Observable。要知道，Rxjava的一个精髓就是“异步”.&lt;/p&gt;

&lt;p&gt;那么到底map和flatMap有什么区别，或者说什么时候使用map什么时候使用flatMap呢？
flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。&lt;/p&gt;

&lt;p&gt;首先，如果你需要将一个类型的对象经过处理（非异步）直接转化成下一个类型，推荐用map，否则的话就用flatMap。
其次，如果你需要在处理中加入容错的机制（特别是你自己封装基于RxJava的网络请求框架），推荐用flatMap。&lt;/p&gt;

&lt;p&gt;flapMap写法的好处&lt;/p&gt;

&lt;p&gt;比如将一个File[] jsonFile中每个File转换成String，用map的话代码为：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Observable.from(jsonFile).map(new Func1&amp;lt;file, string=&quot;&quot;&amp;gt;() {
    @Override public String call(File file) {
        try {
            return new Gson().toJson(new FileReader(file), Object.class);
        } catch (FileNotFoundException e) {
            // So Exception. What to do ?
        }
        return null; // Not good :(
    }
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到这里在出现错误的时候直接抛出异常，这样的处理其实并不好，特别如果你自己封装框架，这个异常不大好去抓取。&lt;/p&gt;

&lt;p&gt;如果用flatMap，由于flatMap的闭包返回值是一个Observable，所以我们可以在这个闭包的call中通过Observable.create的方式来创建Observable，而要知道create方法是可以控制数据流下端的Subscriber的，即可以调用onNext/onCompete/onError方法。如果出现异常，我们直接调用subscribe.onError即可，封装框架也很好感知。代码大致如下：&lt;/p&gt;

&lt;p&gt;```
Observable.from(jsonFile).flatMap(new Func1&amp;lt;file, observable&amp;lt;string=””»() {
    @Override public Observable&lt;string&gt; call(final File file) {
        return Observable.create(new Observable.OnSubscribe&lt;string&gt;() {
            @Override public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber) {
                try {
                    String json = new Gson().toJson(new FileReader(file), Object.class);&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                subscriber.onNext(json);
                subscriber.onCompleted();
            } catch (FileNotFoundException e) {
                subscriber.onError(e);
            }
        }
    });
} }); ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;map操作符通常也用于处理结构化的服务端响应数据，比如下列返回的JSON数据就是一段典型的响应数据&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;message&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;操作成功&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;noVisitCount&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;planCount&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;visitedCount&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在map的闭包中，我们可以先判断status进行统一的出错或者正确（返回data的内容）处理，一般来说，data的内容都是处理成一个泛型&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Jun 2016 00:00:00 +0800</pubDate>
        <link>/2016/06/15/rxjava%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">/2016/06/15/rxjava%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>My BigShow Plan</title>
        <description>&lt;p&gt;关于BigShow, 最重要的是：快！快！快！&lt;/p&gt;

&lt;p&gt;但是我最近确实做慢了。&lt;/p&gt;

&lt;p&gt;应该反思。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;任务300&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;保存数据&lt;/li&gt;
  &lt;li&gt;点击搜索后的第一次自动搜索提示&lt;/li&gt;
  &lt;li&gt;搜索界面的网格视图&lt;/li&gt;
  &lt;li&gt;搜索框的输入与确定&lt;/li&gt;
  &lt;li&gt;搜索框的下拉提示列表&lt;/li&gt;
  &lt;li&gt;选择图片后的图片展示&lt;/li&gt;
  &lt;li&gt;关于网格的第一条Item √&lt;/li&gt;
  &lt;li&gt;关于网格的第后面的Item √&lt;/li&gt;
  &lt;li&gt;关于网格的数据Model √&lt;/li&gt;
  &lt;li&gt;网格图中的划线 √&lt;/li&gt;
  &lt;li&gt;网格图中的右上角数字&lt;/li&gt;
  &lt;li&gt;网格图中的数字操作&lt;/li&gt;
  &lt;li&gt;网格图的点击跳转效果&lt;/li&gt;
  &lt;li&gt;网格图的第一次显示效果&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;翻卷特效&lt;/h2&gt;

&lt;p&gt;https://github.com/harism/android_page_curl
https://github.com/suyonoion/PageCurl_BookView&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;首先是36Kr的一篇文章, 可以借助这个GIF搜索引擎：http://giphy.com/&lt;/p&gt;

&lt;p&gt;微软的Bing也是可以搜索gif图片，但我发现它的图片还是来自Giphy.&lt;/p&gt;

&lt;p&gt;比如搜索南方公园 http://giphy.com/search/south-park&lt;/p&gt;

&lt;p&gt;所以，BigShow的内容方面就有源源不断与时俱进的素材了。&lt;/p&gt;

&lt;p&gt;这里是 Giphy 的文档：https://github.com/Giphy/GiphyAPI&lt;/p&gt;

&lt;p&gt;更多的文档：https://api.giphy.com/  http://giphy.com/labs&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;内容分级&lt;/h2&gt;

&lt;p&gt;关于Parameters,
rating - limit results to those rated (y,g, pg, pg-13 or r).&lt;br /&gt;
  G: General Audiences. All ages admitted.&lt;br /&gt;
  PG: Parental Guidance Suggested. Some material may not be suitable for children.&lt;br /&gt;
  PG-13: Parents Strongly Cautioned. Some material may be inappropriate for children under 13.&lt;br /&gt;
  R: Restricted. Under 17 requires accompanying parent or adult guardian.&lt;br /&gt;
  NC-17: No Children. No one 17 and under admitted.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;选择不光可以是文字，它可以是任何东西。
————————————————————————————————-&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;数据&lt;/h2&gt;

&lt;p&gt;Plot
num(二叉树排序)&lt;br /&gt;
isEnd: 0 非End, 1 End&lt;br /&gt;
dataFrom: (参考项)giphy, user&lt;br /&gt;
dataImg: (jsonstring: data: type:)&lt;br /&gt;
dataText: (jsonstring: data: type:)&lt;br /&gt;
dataChoose: (jsonstring: data: type:)&lt;br /&gt;
fromStory&lt;/p&gt;

&lt;p&gt;Story
[nothing add now]&lt;/p&gt;

&lt;p&gt;关于GiphyAPI&lt;/p&gt;

&lt;p&gt;Translate Endpoint:&lt;br /&gt;
http://api.giphy.com/v1/gifs/translate?s=superman&amp;amp;api_key=dc6zaTOxFJmzC&lt;br /&gt;
将名词转化为特定图片,每次随机一个&lt;/p&gt;

&lt;p&gt;Search Endpoint: &lt;br /&gt;
http://api.giphy.com/v1/gifs/search?q=funny+cat&amp;amp;api_key=dc6zaTOxFJmzC&lt;br /&gt;
通过搜索关键字获得数据列表,默认为25个&lt;/p&gt;

&lt;p&gt;Random Endpoint:&lt;br /&gt;
http://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC&amp;amp;tag=american+psycho&lt;br /&gt;
根据标签随机获得一个数据&lt;/p&gt;

&lt;p&gt;Trending Gifs:&lt;br /&gt;
http://api.giphy.com/v1/gifs/trending?api_key=dc6zaTOxFJmzC&lt;br /&gt;
随机数据流25个&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Gmail之父说过一句话：你需要将某几件事情做得精益求精，而不要追求面面俱到。&lt;/p&gt;

&lt;p&gt;对于BigShow，有3个核心点：
制作：上手环节、自动补全
游戏中：选择、结局、生命值
分类：栏目、排序、推荐&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;关于字体&lt;/p&gt;

&lt;p&gt;我在 http://www.uisdc.com/23-handwritten-english-font 找到了http://www.fontsquirrel.com/fonts/architects-daughter,
该ArchitectsDaughter.ttf字体遵从SIL Open Font License协议。
知乎上其他的 https://www.zhihu.com/question/21759657。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Apr 2016 00:00:00 +0800</pubDate>
        <link>/2016/04/18/my-bigshow-plan/</link>
        <guid isPermaLink="true">/2016/04/18/my-bigshow-plan/</guid>
        
        
        <category>Plan</category>
        
      </item>
    
      <item>
        <title>关于Android graphics的Camera和Matrix</title>
        <description>&lt;h2 id=&quot;android-graphicscameramatrix&quot;&gt;关于Android graphics的Camera和Matrix&lt;/h2&gt;

&lt;h3 id=&quot;camera&quot;&gt;Camera&lt;/h3&gt;

&lt;p&gt;这是camera类的主要方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public native void save();
public native void restore();
public native void translate(float x, float y, float z);
public native void rotateX(float deg);
public native void rotateY(float deg);
public native void rotateZ(float deg);
public native void rotate(float x, float y, float z);
public native float getLocationX();
public native float getLocationY();
public native float getLocationZ();
public native void setLocation(float x, float y, float z);
public void getMatrix(Matrix matrix) {
    nativeGetMatrix(matrix.native_instance);
}
public void applyToCanvas(Canvas canvas) {
    nativeApplyToCanvas(canvas.mNativeCanvas);
}
public native float dotWithNormal(float dx, float dy, float dz);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里是Camera变换的坐标轴
&lt;img src=&quot;/img/20120929085945172.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在rotate的时候，要站在该轴正方向的地方看，才能明白他的旋转。
如 camera.rotateZ(-60)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/20120929085945172.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;matrix&quot;&gt;Matrix&lt;/h3&gt;

&lt;p&gt;Matrix是一个3 x 3的2D空间矩阵&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/tindle/Desktop/1349614431_7130.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MPERSP_2指的是投影变换,其实际作用就是如果MPERSP_2=0.5，那么物体是原来的4倍大小；如果MPERSP_2=2，那么物体是原来的1/4大小。&lt;/p&gt;

&lt;p&gt;Camera和Matrix的联合使用：一般情况下，如果我们需要进行3D变换，那么需要将Camera和Matrix联合使用，使用Camera进行x轴或y轴的旋转，使用Matrix进行平移或放大。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/10/android-graphics%E7%9A%84camera%E5%92%8Cmatrix/</link>
        <guid isPermaLink="true">/2016/03/10/android-graphics%E7%9A%84camera%E5%92%8Cmatrix/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>关于RxJava的使用</title>
        <description>&lt;p&gt;RxJava 的观察者模式
RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。&lt;/p&gt;

&lt;p&gt;与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。&lt;/p&gt;

&lt;p&gt;1) 创建 Observer&lt;br /&gt;
Observer 即观察者&lt;/p&gt;

&lt;p&gt;Observer&lt;string&gt; observer = new Observer&lt;string&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}
 
@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Subscriber&lt;string&gt; subscriber = new Subscriber&lt;string&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}
 
@Override
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;他们的基本使用方式是完全一样的&lt;/p&gt;

&lt;p&gt;2) 创建 Observable&lt;br /&gt;
Observable 即被观察者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Observable observable = Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {
@Override
public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber) {
    subscriber.onNext(&quot;Hello&quot;);
    subscriber.onNext(&quot;Hi&quot;);
    subscriber.onNext(&quot;Aloha&quot;);
    subscriber.onCompleted();
}});

Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();

String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面 just(T…) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。&lt;/p&gt;

&lt;p&gt;3) Subscribe (订阅)&lt;br /&gt;
创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;observable.subscribe(observer);
// 或者：
observable.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出Subscriber：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;() {
// onNext()
@Override
public void call(String s) {
    Log.d(tag, s);
}
};
Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;() {
// onError()
@Override
public void call(Throwable throwable) {
    // Error handling
}
};
Action0 onCompletedAction = new Action0() {
// onCompleted()
@Override
public void call() {
    Log.d(tag, &quot;completed&quot;);
}
};
 
// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 	onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 	onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, 	onCompletedAction);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;线程控制 —— Scheduler&lt;/p&gt;

&lt;p&gt;subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。
observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Observable.just(1, 2, 3, 4)
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Action1&amp;lt;Integer&amp;gt;() {
    @Override
    public void call(Integer number) {
        Log.d(tag, &quot;number:&quot; + number);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;变换&lt;/h3&gt;

&lt;p&gt;map(): 事件对象的直接变换，它是 RxJava 最常用的变换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
.map(new Func1&amp;lt;String, Bitmap&amp;gt;() {
    @Override
    public Bitmap call(String filePath) { // 参数类型 String
        return getBitmapFromPath(filePath); // 返回类型 Bitmap
    }
})
.subscribe(new Action1&amp;lt;Bitmap&amp;gt;() {
    @Override
    public void call(Bitmap bitmap) { // 参数类型 Bitmap
        showBitmap(bitmap);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;map() 是一对一的转化，而我现在的要求是一对多的转化, 就需要用 flatMap()了.&lt;/p&gt;

 	Student[] students = …;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Subscriber&amp;lt;Course&amp;gt; subscriber = new Subscriber&amp;lt;Course&amp;gt;() {
@Override
public void onNext(Course course) {
    Log.d(tag, course.getName());
}
...
};
Observable.from(students)
.flatMap(new Func1&amp;lt;Student, Observable&amp;lt;Course&amp;gt;&amp;gt;() {
    @Override
    public Observable&amp;lt;Course&amp;gt; call(Student student) {
        return Observable.from(student.getCourses());
    }
})
.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。通过 observeOn() 的多次调用，程序实现了线程的多次切换.&lt;/p&gt;

 	Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.subscribeOn(Schedulers.io())
.observeOn(Schedulers.newThread())
.map(mapOperator) // 新线程，由 observeOn() 指定
.observeOn(Schedulers.io())
.map(mapOperator2) // IO 线程，由 observeOn() 指定
.observeOn(AndroidSchedulers.mainThread) 
.subscribe(subscriber);  // Android 主线程，由 observeOn() 指定
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;至此，结束。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Mar 2016 00:00:00 +0800</pubDate>
        <link>/2016/03/05/%E5%85%B3%E4%BA%8Erxjava%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">/2016/03/05/%E5%85%B3%E4%BA%8Erxjava%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>关于StaticLayout和DynamicLayout</title>
        <description>&lt;p&gt;StaticLayout 来自 http://developer.android.com/reference/android/text/StaticLayout.html&lt;/p&gt;

&lt;p&gt;DynamicLayout 来自 http://developer.android.com/reference/android/text/DynamicLayout.html&lt;/p&gt;

&lt;h2 id=&quot;cerditsroll&quot;&gt;CerditsRoll&lt;/h2&gt;

&lt;p&gt;在该项目中，使用了一些&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Feb 2016 00:00:00 +0800</pubDate>
        <link>/2016/02/17/%E5%85%B3%E4%BA%8Estaticlayout%E5%92%8Cdynamiclayout/</link>
        <guid isPermaLink="true">/2016/02/17/%E5%85%B3%E4%BA%8Estaticlayout%E5%92%8Cdynamiclayout/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Screen Density</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;宽高计算&lt;/h1&gt;

&lt;p&gt;在Activity中，可以这样获得宽高密：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
	float mDensity = getBaseContext().getResources().getDisplayMetrics().density;
	float mScreenHeight = getBaseContext().getResources().getDisplayMetrics().heightPixels;
    float mScreenWidth = getBaseContext().getResources().getDisplayMetrics().widthPixels;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如，我的手机Nexus6手机的分辨率是 1440*2560，
打印出的数据是：
desity:3.5
height:2392.0
width:1440.0&lt;/p&gt;

&lt;p&gt;接下来，查看statusBar和navigationBar的高度：&lt;/p&gt;

&lt;p&gt;```
    //获取statusBar高度
    public int getStatusBarHeight(Context context){
        int result = 0;
        int resourceId = context.getResources().getIdentifier(“status_bar_height”, “dimen”, “android”);
        if(resourceId&amp;gt;0){
            result = context.getResources().getDimensionPixelSize(resourceId);
        }
        return result;
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取底部navigationBar高度
public int getNavigationBarHeight(Context context) {
    int result = 0;
    int resourceId = context.getResources().getIdentifier(&quot;navigation_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);
    if(resourceId&amp;gt;0){
        result = context.getResources().getDimensionPixelSize(resourceId);
    }
    return result;
} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印出的数据：
statusbar height:84
navigationbar height:168&lt;/p&gt;

&lt;p&gt;接下来计算：
168/3.5=48
2560-2392=168, 所以NavigationBar包括了StatusBar.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dp2px&quot;&gt;dp2px&lt;/h2&gt;

&lt;p&gt;实际，返回的值是 (int)(dp * density + 0.5f);&lt;/p&gt;

&lt;h3 id=&quot;rootview&quot;&gt;RootView&lt;/h3&gt;

&lt;p&gt;```
    public void init(){
        ViewGroup decor = (ViewGroup) mActivity.getWindow().getDecorView();
        ViewGroup contentParent = (ViewGroup)mActivity.findViewById(android.R.id.content);
        View rootView = contentParent.getChildAt(0);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if(loadview==null){
        loadview = LayoutInflater.from(mActivity).inflate(R.layout.layout_loadindview,null);
        FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        lp.gravity = Gravity.CENTER;
        loadview.setLayoutParams(lp);
        contentParent.addView(loadview);
        loadview.setVisibility(View.GONE);
    }
} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;屏幕截图&lt;/h3&gt;

&lt;p&gt;```
    private void getBitmapScreenshot() {
        //create save path to for file
        String mPath = Environment.getExternalStorageDirectory().toString() + “/” + IMAGE_FILENAME;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //create bitmap screenshot
    Bitmap bitmap;
    //remove .getRootView() if you want everything but the actionbar.
    View view = getWindow().getDecorView().findViewById(android.R.id.content).getRootView();
    view.setDrawingCacheEnabled(true);
    bitmap = Bitmap.createBitmap(view.getDrawingCache());
    view.setDrawingCacheEnabled(false);

    OutputStream fileOut = null;
    File imageFile = new File(mPath);

    try {
        fileOut = new FileOutputStream(imageFile);
        bitmap.compress(Bitmap.CompressFormat.JPEG, 90, fileOut);
        fileOut.flush();
        fileOut.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }

    Uri uri = Uri.fromFile(new File(mPath));
    //done. next steps are optional. just displaying screenshot for you in app.
    Picasso.with(this)
           .load(uri)
           .into(mScreenshotImageView);
    mPathTextView.setText(&quot;Screenshot saved at: &quot; + mPath);
} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;viewscreendwindowdecorview&quot;&gt;获取View在Screend中的坐标(或者说在Window或者DecorView中)&lt;/h3&gt;

&lt;p&gt;```
int[] location = new int[2];
View.getLocationOnScreen(location);
//或者
int[] location = new int[2];
View.getLocationInWindow(location);&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3 id=&quot;navigationbar&quot;&gt;判断是否存在NavigationBar&lt;/h3&gt;

&lt;p&gt;单纯计算高度是不行的，因为高度值都不为0.&lt;/p&gt;

&lt;p&gt;```
public static boolean checkDeviceHasNavigationBar(Context context) {
    boolean hasNavigationBar = false;
    Resources rs = context.getResources();
    int id = rs.getIdentifier(“config_showNavigationBar”, “bool”, “android”);
    if (id &amp;gt; 0) {
        hasNavigationBar = rs.getBoolean(id);
    }
    try {
        Class systemPropertiesClass = Class.forName(“android.os.SystemProperties”);
        Method m = systemPropertiesClass.getMethod(“get”, String.class);
        String navBarOverride = (String) m.invoke(systemPropertiesClass, “qemu.hw.mainkeys”);
        if (“1”.equals(navBarOverride)) {
            hasNavigationBar = false;
        } else if (“0”.equals(navBarOverride)) {
            hasNavigationBar = true;
        }
    } catch (Exception e) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}
return hasNavigationBar;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;隐藏NavigationBar,在3.0以后可以这么做：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 08 Feb 2016 19:59:05 +0800</pubDate>
        <link>/2016/02/08/screen-density/</link>
        <guid isPermaLink="true">/2016/02/08/screen-density/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Volley 源码分析</title>
        <description>&lt;h1 id=&quot;volley-&quot;&gt;Volley 源码分析&lt;/h1&gt;

&lt;h2 id=&quot;http&quot;&gt;Http缓存机制&lt;/h2&gt;

&lt;p&gt;如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。&lt;/p&gt;

&lt;p&gt;在 BasicNetwork.java 中，有下面方法:&lt;/p&gt;

&lt;p&gt;```
    public NetworkResponse performRequest(Request&amp;lt;?&amp;gt; request) throws VolleyError {
        long requestStart = SystemClock.elapsedRealtime();
        while (true) {
            HttpResponse httpResponse = null;
            byte[] responseContents = null;
            Map&amp;lt;String, String&amp;gt; responseHeaders = new HashMap&amp;lt;String, String&amp;gt;();
            try {
                // Gather headers.
                Map&amp;lt;String, String&amp;gt; headers = new HashMap&amp;lt;String, String&amp;gt;();
                addCacheHeaders(headers, request.getCacheEntry());
                httpResponse = mHttpStack.performRequest(request, headers);
                StatusLine statusLine = httpResponse.getStatusLine();
                int statusCode = statusLine.getStatusCode();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            responseHeaders = convertHeaders(httpResponse.getAllHeaders());
            // Handle cache validation.
            if (statusCode == HttpStatus.SC_NOT_MODIFIED) {
            // 响应码：304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
                return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED,
                        request.getCacheEntry() == null ? null : request.getCacheEntry().data,
                        responseHeaders, true);
            }

            // Some responses such as 204s do not have content.  We must check.
            if (httpResponse.getEntity() != null) {
              responseContents = entityToBytes(httpResponse.getEntity());
            } else {
              // Add 0 byte response as a way of honestly representing a
              // no-content request.
              responseContents = new byte[0];
            }

            // if the request is slow, log it.
            long requestLifetime = SystemClock.elapsedRealtime() - requestStart;
            logSlowRequests(requestLifetime, request, responseContents, statusLine);

            // 响应码：小于200或者大于299,且除去之前安已经判断过的301,302,和204类的响应之外，其余的响应都表示该请求失败
            if (statusCode &amp;lt; 200 || statusCode &amp;gt; 299) {
                throw new IOException();
            }
            return new NetworkResponse(statusCode, responseContents, responseHeaders, false);
        } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Volley使用的Http缓存机制 与 Http协议的”Etag&amp;amp;Last-Modified”缓存机制有关。Etag有两种用法 If-Match/If-None-Match，是用来判断服务器的对象和客户端的URL对象是否匹配。
关于Etag在后面#补充中做简单介绍。下面是  BasicNetwork.java 的源码：&lt;/p&gt;

&lt;p&gt;```
private void addCacheHeaders(Map&amp;lt;String, String&amp;gt; headers, Cache.Entry entry) {
        // If there’s no cache entry, we’re done.
        if (entry == null) {
            return;
        }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if (entry.etag != null) {
        headers.put(&quot;If-None-Match&quot;, entry.etag);
    }

    if (entry.serverDate &amp;gt; 0) {
        Date refTime = new Date(entry.serverDate);
        headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));
    }
}     ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先我们应该明白在Http协议中[“Etag”,”If-None-Match”,”Last-Modified”,”If-Modified-Since”]都是头信息，这四个头构成了Http协议的一种缓存机制，称作”Etag&amp;amp;Last-Modified”缓存机制，”Etag”对应的头就是”If-None-Match”，同样”Last-Modified”对应的头为”If-Modified-Since.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再进一步，我们分析一下Etag机制，Etag存储的是访问资源的属性，标识着该资源和上一次对比，是否被修改过，我们可以暂且认为Etag的值为资源的MD5。”If-None-Match”是请求头，而”Etag”是响应头，客户端第一次请求某个资源的时候，该资源的Etag还没有在本地存储，所以我们对资源的第一次Request中If-None-Match应该是null，接着，服务器返回的时候把Etag的值是放到了响应头中返回过来，我们收到该Etag之后存储起来，第二次对相同的资源进行请求的时候，我们就有了该资源的Etag的值(以If-None-Match头形式发送)，服务器收到If-None-Match头信息之后，判断我们发过去的If-None-Match和服务器上的Etag是否一致，如果一致就返回304，表示该资源没有被修改，不返回请求内容，我们直接使用上一次缓存的资源即可，如果有修改，就返回新的Etag值和请求内容，如果我们不使用Etag机制的话，每次请求同一个资源都会返回200和请求内容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再说说Last-Modified，If-Modified-Since是请求头，Last-Modified是响应头，两个头存储的都是资源最后一次被修改的时间，和Etag的流程一样，客户端第一次请求资源是没有If-Modified-Since头信息的，服务器则老老实实返回资源内容加上Last-Modified头，客户端收到之后进行缓存，再次请求同一个资源时，则会在请求头上加上If-Modified-Since时间戳，服务器收到If-Modified-Since时间戳之后和对应的资源的Last-Modified时间戳作对比，如果一致就返回304，不一致返回新的Last-Modified时间戳和资源内容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首先是对我们上面讲过的”Etag&amp;amp;Last-Modified”机制结果的判断，如果服务器返回了304，则认为请求资源已经被缓存，我们直接使用本地的缓存资源即可，需要注意的是在这里做了一个判断，如果本次Request的CacheEntry为空，则表示本地没有对应的缓存子资源，但是服务器又返回了304，则说明这个资源是没有实体数据的，所以NetworkResponse的data字段为null。还有就是304头字段不完整的问题，我们可以去看看它给出的文档，在这里不做多讲。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;if-modified-sinceif-none-match&quot;&gt;“If-Modified-Since”以及“If-None-Match”两种头部&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If-Modified-Since&lt;br /&gt;
  若server回复的报头中存在“Last-Modified”，那么客户端一定要在下一次请求报头中包含“If-Modified-Since”，所以说，这两个头部是相互对应的。那么当服务器收到客户端回复的“If-Modified-Since”头部之后会如何处理呢？首先服务器通过比较这两个时间，若“Last-Modified”更大，表明客户端缓存中的内容已经过时，此时server会将最新的文档（附上新的Header）返回给客户端，并且状态码为200；否则认为客户端缓存中的内容仍然是最新的，只需向客户端返回304状态码，同时包含最新的HTTP头部。下图比较形象地显示了这两种处理情况。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;./img/20120929085945571.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If-None-Match&lt;br /&gt;
   可以明显看出，“If-Modified-Since”实现重验证主要是通过比较时间来完成的，但是在某些情况下，它并不能十分凑效：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;服务器上的文档被后台进程周期性地重写，此时虽然日期发生了变化，但是内容却没有发生任何改变；&lt;/li&gt;
      &lt;li&gt;虽然服务器上的内容发生了改变，但是却只是一些不太重要的信息，比如说拼写错误等等，这样就导致文     档在客户端重载，显然开销过大；&lt;/li&gt;
      &lt;li&gt;一些web服务器上很难精确计算出文档的修改日期；&lt;/li&gt;
      &lt;li&gt;对于实时系统而言（文档修改在很短的时间内完成），显然也显得无能为力。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;基于以上几点，HTTP规范定义了另外一种方式，即比较文档标签(Entity tags, Etags).它的基本思想是为每一个文档生成一个Etag，它可以是某个序列号、版本号或者检验。同样“If-None-Match”头部是与server端的“Etag”头部是相对应的，这样server端只需要比较标签号就可以判断出客户端缓存中的文档是否是最新的，其处理方式与“If-Modified-Since”类似，下图是服务器与客户端的一种交互情况：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;./img/20120929085945172.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;如何进行重连？&lt;/h2&gt;

&lt;p&gt;还是在&lt;/p&gt;

&lt;p&gt;我们看到如下代码：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
            } catch (SocketTimeoutException e) {
                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());
            } catch (ConnectTimeoutException e) {
                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());
            } catch (MalformedURLException e) {
                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);
            } catch (IOException e) {
                int statusCode = 0;
                NetworkResponse networkResponse = null;
                if (httpResponse != null) {
                    statusCode = httpResponse.getStatusLine().getStatusCode();
                } else {
                    throw new NoConnectionError(e);
                }
                VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());
                if (responseContents != null) {
                    networkResponse = new NetworkResponse(statusCode, responseContents,
                            responseHeaders, false);
                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||
                            statusCode == HttpStatus.SC_FORBIDDEN) {
                        attemptRetryOnException(&quot;auth&quot;,
                                request, new AuthFailureError(networkResponse));
                    } else {
                        // TODO: Only throw ServerError for 5xx status codes.
                        throw new ServerError(networkResponse);
                    }
                } else {
                    throw new NetworkError(networkResponse);
                }
            }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的代码中出下了三次 attemptRetryOnException&lt;/p&gt;

&lt;p&gt;```
    private static void attemptRetryOnException(String logPrefix, Request&amp;lt;?&amp;gt; request,
            VolleyError exception) throws VolleyError {
        RetryPolicy retryPolicy = request.getRetryPolicy();
        int oldTimeout = request.getTimeoutMs();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    try {
        retryPolicy.retry(exception);
    } catch (VolleyError e) {
        request.addMarker(
                String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));
        throw e;
    }
    request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));
} ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;补充&lt;/h2&gt;

&lt;h3 id=&quot;httplast-modifiedetag&quot;&gt;http响应Last-Modified和ETag&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;基础知识
　　1) 什么是”Last-Modified”?
　　在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记此文件在服务期端最后被修改的时间，格式类似这样：
　　Last-Modified: Fri, 12 May 2006 18:53:33 GMT
　　客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：
　　If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT
　　如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。
　　2) 什么是”Etag”?
　　HTTP 协议规格说明定义ETag为“被请求变量的实体值” （参见 —— 章节 14.19）。 另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：
　　ETag: “50b1c1d4f775c61:df3”
　　客户端的查询更新格式是这样的：
　　If-None-Match: W/”50b1c1d4f775c61:df3”
　　如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。本人测试Etag主要在断点下载时比较有用。
　　Last-Modified和Etags如何帮助提高性能?
　　聪明的开发者会把Last-Modified 和ETags请求的http报头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生 Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
　　过程如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;客户端请求一个页面（A）。&lt;/li&gt;
  &lt;li&gt;服务器返回页面A，并在给A加上一个Last-Modified/ETag。&lt;/li&gt;
  &lt;li&gt;客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。&lt;/li&gt;
  &lt;li&gt;客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。&lt;/li&gt;
  &lt;li&gt;服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 01 Jan 2016 00:00:00 +0800</pubDate>
        <link>/2016/01/01/volley-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">/2016/01/01/volley-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
        
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>NSString Some Useful Methods</title>
        <description>&lt;p&gt;2015-11-26-NSString Some Useful Methods&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;[string substringToIndex:N]
 get substring from 0 to N-1;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[string substringFromIndex:N]
 get substring form N to length-1;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[string substringWithRange:NSMakeRange(N,M)]
 get substring from N to N+M-1;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;([string rangeOfString:@“A”].location == NSNotFound)
 check substring contains ‘A’;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Get Range Of String
 ```
`NSString*string =@“abcdefgh”;
NSRange range = &lt;a href=&quot;&quot;&gt;string rangeOfString:@”fg”&lt;/a&gt;;
NSLog(@”rang:%@”,NSStringFromRange(range));//{5,2}
string = &lt;a href=&quot;&quot;&gt;string substringWithRange:range&lt;/a&gt;;
```
`&lt;/li&gt;
  &lt;li&gt;Separate String
```
`NSString*string =@“123A456”;
NSArray *array = &lt;a href=&quot;&quot;&gt;string componentsSeparatedByString:@”A”&lt;/a&gt;;
NSLog(@”array:%@”,array); 
```
`&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 26 Nov 2015 00:00:00 +0800</pubDate>
        <link>/2015/11/26/nsstring-some-useful-methods/</link>
        <guid isPermaLink="true">/2015/11/26/nsstring-some-useful-methods/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>SoftKeyBoard</title>
        <description>&lt;p&gt;iOS UITextView UITextField About SoftKeyBoard&lt;/p&gt;

&lt;p&gt;一、键盘风格   
UIKit框架支持8种风格键盘。
.	typedef enum   
.	    UIKeyboardTypeDefault,                // 默认键盘：支持所有字符   
.	    UIKeyboardTypeASCIICapable,           // 支持ASCII的默认键盘   
.	    UIKeyboardTypeNumbersAndPunctuation,  // 标准电话键盘，支持+*#等符号   
.	    UIKeyboardTypeURL,                    // URL键盘，有.com按钮；只支持URL字符   
.	    UIKeyboardTypeNumberPad,              //数字键盘   
.	    UIKeyboardTypePhonePad,               // 电话键盘   
.	    UIKeyboardTypeNamePhonePad,           // 电话键盘，也支持输入人名字   
.	    UIKeyboardTypeEmailAddress,           // 用于输入电子邮件地址的键盘   
.	} UIKeyboardType;  
用法用例：
textView.keyboardtype = UIKeyboardTypeNumberPad;&lt;/p&gt;

&lt;p&gt;二、键盘外观
.	typedef enum   
.	    UIKeyboardAppearanceDefault,    // 默认外观：浅灰色   
.	    UIKeyboardAppearanceAlert,      //深灰/石墨色   
.	} UIKeyboardAppearance;  
用法用例：
textView.keyboardAppearance=UIKeyboardAppearanceDefault;&lt;/p&gt;

&lt;p&gt;三、回车键
.	typedef enum   
.	    UIReturnKeyDefault,  //默认：灰色按钮，标有Return
.	    UIReturnKeyGo,  //标有Go的蓝色按钮
.	    UIReturnKeyGoogle,  //标有Google的蓝色按钮，用于搜索
.	    UIReturnKeyJoin,  //标有Join的蓝色按钮
.	    UIReturnKeyNext,  //标有Next的蓝色按钮
.	    UIReturnKeyRoute,  //标有Route的蓝色按钮
.	    UIReturnKeySearch,  //标有Search的蓝色按钮
.	    UIReturnKeySend,  //标有Send的蓝色按钮
.	    UIReturnKeyYahoo,  //标有Yahoo!的蓝色按钮，用于搜索
.	    UIReturnKeyDone,  //标有Done的蓝色按钮
.	    UIReturnKeyEmergencyCall,  //紧急呼叫按钮
.	} UIReturnKeyType;  
用法用例：
textView.returnKeyType=UIReturnKeyGo;&lt;/p&gt;

&lt;p&gt;四、自动大写
.	typedef enum   
.	    UITextAutocapitalizationTypeNone, //不自动大写   
.	    UITextAutocapitalizationTypeWords, //单词首字母大写   
.	    UITextAutocapitalizationTypeSentences, //句子首字母大写   
.	    UITextAutocapitalizationTypeAllCharacters, //所有字母大写   
.	} UITextAutocapitalizationType;  
用法用例：
textField.autocapitalizationType = UITextAutocapitalizationTypeWords;&lt;/p&gt;

&lt;p&gt;五、自动更正
.	typedef enum   
.	    UITextAutocorrectionTypeDefault,//默认   
.	    UITextAutocorrectionTypeNo,//不自动更正   
.	    UITextAutocorrectionTypeYes,//自动更正   
.	} UITextAutocorrectionType;  
用法用例：
textField.autocorrectionType = UITextAutocorrectionTypeYes;&lt;/p&gt;

&lt;p&gt;六、安全文本输入
textView.secureTextEntry=YES;
开启安全输入主要是用于密码或一些私人数据的输入，此时会禁用自动更正和自此缓存。&lt;/p&gt;

&lt;p&gt;统计字符：
1、UITextView
- (void)textViewDidChange:(UITextView *)textView&lt;/p&gt;

&lt;p&gt;int count = &lt;a href=&quot;#&quot;&gt;textView.text length&lt;/a&gt;;
//这里的count就是字符个数了
}&lt;/p&gt;

&lt;p&gt;2、UITextField
方法一：
自己先为UITextField的Editing Changed事件添加一个响应方法
-(IBAction)valuechange//m_TextField是UITextField的一个IBOutlet&lt;/p&gt;

&lt;p&gt;int count = &lt;a href=&quot;#&quot;&gt;m_TextField.text length&lt;/a&gt;;
 //count就是当前的字符个数
//下边是将字符限制在140以内
if (&lt;a href=&quot;#&quot;&gt;m_TextField.text length&lt;/a&gt;&amp;gt;140) 
[m_TextField setText:&lt;a href=&quot;#&quot;&gt;m_TextField.text substringToIndex:140&lt;/a&gt;];//多出140时，只取前140个字符
}
}&lt;/p&gt;

&lt;p&gt;方法二：
在代理方法：- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string，判断range.length的值来判断输入的是回格还是其它字符&lt;/p&gt;

&lt;p&gt;响应Return键：
1、UITextView
//代理方法
- (BOOL)textView:(UITextView &lt;em&gt;)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString &lt;/em&gt;)text&lt;/p&gt;

&lt;p&gt;if (1 == range.length) //按下回格键
return YES;
}
if (&lt;a href=&quot;#&quot;&gt;text isEqualToString:@”n”&lt;/a&gt;) //按下return键
//这里隐藏键盘，不做任何处理
&lt;a href=&quot;#&quot;&gt;textView resignFirstResponder&lt;/a&gt;;
return NO;
}else 
if (&lt;a href=&quot;#&quot;&gt;textView.text length&lt;/a&gt; &amp;lt; 140) //判断字符个数
return YES;
}&lt;br /&gt;
}
return NO;
}&lt;/p&gt;

&lt;p&gt;2、UITextField
这个直接有代理方法哈
- (BOOL)textFieldShouldReturn:(UITextField *)textField&lt;/p&gt;

&lt;p&gt;UITextField进入编辑状态 获得焦点 becomeFirstResponder
 关闭键盘 resignFirstResponder&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Sep 2015 22:06:05 +0800</pubDate>
        <link>/2015/09/25/about-ios-softkeyboard/</link>
        <guid isPermaLink="true">/2015/09/25/about-ios-softkeyboard/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>What I Use Git to Build Blog</title>
        <description>&lt;h1 id=&quot;what-i-use-git-to-build-blog&quot;&gt;What I Use Git to Build Blog&lt;/h1&gt;

&lt;p&gt;First git repository is empty.&lt;/p&gt;

&lt;p&gt;So we should first add and commit to init the master branch.&lt;/p&gt;

&lt;p&gt;After above, you could make a new branch.&lt;/p&gt;

&lt;p&gt;init a new branch&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git branch testing&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;show all branch&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git branch -a &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;check what status it is now&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git status &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This article is really detailed.
&lt;a href=&quot;http://blog.jobbole.com/25808/&quot;&gt;http://blog.jobbole.com/25808/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git checkout —orphan gh-pages &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git add . &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git commit -m &quot;first post&quot; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git remote add origin https://github.com/username/projectName.git &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; $ git push origin gh-pages &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;—- Finally, I found it.
&lt;a href=&quot;http://tindlewei.github.io/WeiBlog/&quot;&gt;http://tindlewei.github.io/WeiBlog/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What Helped me. 
&lt;a href=&quot;http://www.aymerick.com/2014/07/22/jekyll-github-pages-bower-bootstrap.html&quot;&gt;http://www.aymerick.com/2014/07/22/jekyll-github-pages-bower-bootstrap.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Oops, I installed bower &lt;a href=&quot;https://github.com/bower/bower&quot;&gt;https://github.com/bower/bower&lt;/a&gt;
Also installed grunt &lt;a href=&quot;http://gruntjs.com/&quot;&gt;GRUNT&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Sep 2015 22:06:05 +0800</pubDate>
        <link>/2015/09/06/what-i-use-git-to-build-blog/</link>
        <guid isPermaLink="true">/2015/09/06/what-i-use-git-to-build-blog/</guid>
        
        
        <category>Jekyll</category>
        
      </item>
    
  </channel>
</rss>
