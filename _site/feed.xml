<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="2.4.0">Jekyll</generator>
<link href="/feed.xml" rel="self" type="application/atom+xml" />
<link href="/" rel="alternate" type="text/html" />
<updated>2016-08-20T17:58:00+08:00</updated>
<id>/</id>
<subtitle>Adam is my name, Black is my color.</subtitle>
<entry>
<title>Flask使用记录</title>
<link href="/Flask%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="Flask使用记录" />
<published>2016-08-09T00:00:00+08:00</published>
<updated>2016-08-09T00:00:00+08:00</updated>
<id>/Flask使用记录</id>
<content type="html" xml:base="/Flask%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/">&lt;h2 id=&quot;section&quot;&gt;配置时的一些命令&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
$ git clone https://github.com/miguelgrinberg/flasky.git
$ cd flasky
$ git checkout 1a
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ source venv/bin/activate
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;deactivate&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt; (venv) $ pip install flask&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(venv) $ pip freeze &amp;gt;requirements.txt&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;
pip install -r requirements.txt
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; db.create_all()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python manage.py db upgrade&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
(venv) $ python manage.py shell
&amp;gt;&amp;gt;&amp;gt; u = User(email=&#39;john@example.com&#39;, username=&#39;john&#39;, password=&#39;cat&#39;)
&amp;gt;&amp;gt;&amp;gt; db.session.add(u)
&amp;gt;&amp;gt;&amp;gt; db.session.commit()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
(venv) $ python manage.py shell
&amp;gt;&amp;gt;&amp;gt; db.drop_all()
&amp;gt;&amp;gt;&amp;gt; db.create_all()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
(venv) $ python manage.py shell
      &amp;gt;&amp;gt;&amp;gt; Role.insert_roles()
      &amp;gt;&amp;gt;&amp;gt; Role.query.all()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;http://www.cnblogs.com/bitCoin/p/5485032.html&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一些错误处理&lt;/h2&gt;

&lt;h3 id=&quot;pip&quot;&gt;pip升级库&lt;/h3&gt;

&lt;p&gt;在 $python manager.py db migrate的时候,
报错版本号不够，可以这样升级库：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo pip install --upgrade alembic&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;db-migrate&quot;&gt;DB Migrate时出错:&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;File “/Users/tindle/Company2/board/board/models.py”, line 73, in ColumnHas
  created_at = Column(DateTime, nullable=False, default=datetime.now)
TypeError: &lt;strong&gt;init&lt;/strong&gt;() got an unexpected keyword argument ‘default’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DateTime doesn’t have a default key as an input. The default key should be an input to the Column function. Try this:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;created_at = Column(DateTime, default=datetime.datetime.utcnow)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;or&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;from sqlalchemy.sql import func&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;created_at = Column(DateTime(timezone=True), default=func.now())&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;运行时报错：&lt;/h3&gt;

&lt;p&gt;AttributeError: type object ‘datetime.datetime’ has no attribute ‘datetime’&lt;/p&gt;

&lt;p&gt;&lt;code&gt;from datetime import datetime&lt;/code&gt; 改为 &lt;code&gt;import datetime&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;部署到服务器&lt;/h2&gt;

&lt;h3 id=&quot;virtualenvsupervisornginxgunicorn&quot;&gt;virtualenv+supervisor+nginx+gunicorn&lt;/h3&gt;

&lt;p&gt;http://www.v2ex.com/t/267868&lt;/p&gt;

&lt;p&gt;http://www.jikexueyuan.com/course/2060.html&lt;/p&gt;

&lt;p&gt;http://www.simpleapples.com/2015/06/configure-nginx-supervisor-gunicorn-flask/&lt;/p&gt;

&lt;p&gt;http://codingnow.cn/server/539.html&lt;/p&gt;

&lt;p&gt;http://gunicorn.org/&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;Python爬虫&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20899988&quot;&gt;https://www.zhihu.com/question/20899988&lt;/a&gt;&lt;/p&gt;
</content>
<summary>配置时的一些命令</summary>
</entry>
<entry>
<title>Android动态修改Menu</title>
<link href="/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9Menu/" rel="alternate" type="text/html" title="Android动态修改Menu" />
<published>2016-07-21T00:00:00+08:00</published>
<updated>2016-07-21T00:00:00+08:00</updated>
<id>/Android动态修改Menu</id>
<content type="html" xml:base="/Android%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9Menu/">&lt;h2 id=&quot;fragmentactivity&quot;&gt;打开一个包含Fragment的Activity:&lt;/h2&gt;
&lt;p&gt;### – 普通方式 –&lt;/p&gt;

&lt;p&gt;这个普通的步骤就可以：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加 &lt;code&gt;setHasOptionsMenu(true);&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;onCreateOptionMenu&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;onOptionItemSeleted&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;重要Tip:&lt;/strong&gt;  &lt;br /&gt;
需要在 onCreate 或 onCreateView中加入 &lt;code&gt;setHasOptionsMenu(true);&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;activityfragment&quot;&gt;在Activity中切换Fragment:&lt;/h2&gt;
&lt;p&gt;### – 特殊方式 –&lt;/p&gt;

&lt;p&gt;初始化时调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
	getActivity().supportInvalidateOptionsMenu();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;切换需要调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
    public void onPrepareOptionsMenu(Menu menu) {
        menu.clear();
        MenuInflater inflater = getActivity().getMenuInflater();
        inflater.inflate(R.menu.menu_zeus_save, menu);
        super.onPrepareOptionsMenu(menu);
    }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在ViewPager切换监听调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
getActivity().invalidateOptionsMenu();
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;补充&lt;/h2&gt;

&lt;p&gt;这里说一下 &lt;code&gt;onCreateOptionsMenu&lt;/code&gt; 和 &lt;code&gt;onPrepareOptionsMenu&lt;/code&gt; 的区别&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;onCreateOptionsMenu：&lt;br /&gt;
只会调用一次，他只会在Menu显示之前去调用一次，之后就不会在去调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;onPrepareOptionsMenu：&lt;br /&gt;
每次在display Menu之前，都会去调用，只要按一次Menu按鍵，就会调用一次。所以可以在这里动态的改变menu。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;searchview&quot;&gt;SearchView&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;
    &amp;lt;item android:id=&quot;@+id/action_search&quot;
        android:title=&quot;Search&quot;
        android:icon=&quot;@mipmap/ic_action_search&quot;
        app:showAsAction=&quot;collapseActionView|always&quot;
        android:animateLayoutChanges=&quot;true&quot;
        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;/&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```
    public void initSearchView(final Menu menu) {
        SearchManager searchManager = (SearchManager) getActivity().getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = menu.findItem(R.id.action_search);
        if (searchItem != null) {
            MenuItemCompat.setOnActionExpandListener(
                    searchItem, new MenuItemCompat.OnActionExpandListener() {
                        &lt;a href=&quot;https://github.com/Override&quot; class=&quot;user-mention&quot;&gt;@Override&lt;/a&gt;
                        public boolean onMenuItemActionExpand(MenuItem item) {
                            return true;
                        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
                    public boolean onMenuItemActionCollapse(MenuItem item) {
                        return true;
                    }
                });
        mSearchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        mSearchView.setInputType(InputType.TYPE_TEXT_VARIATION_FILTER);
        mSearchView.setImeOptions(EditorInfo.IME_ACTION_DONE | EditorInfo.IME_FLAG_NO_FULLSCREEN);
        mSearchView.setQueryHint(getString(R.string.action_search));
        mSearchView.setSearchableInfo(searchManager.getSearchableInfo(getActivity().getComponentName()));
        mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
            &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
            public boolean onQueryTextSubmit(String query) {
                return onQueryTextChange(query);
            }

            &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
            public boolean onQueryTextChange(String newText) {
                Toast.makeText(getActivity(), newText, Toast.LENGTH_SHORT).show();
                return true;
            }
        });
    }
} ```
&lt;/code&gt;&lt;/pre&gt;

</content>
<summary>打开一个包含Fragment的Activity:### – 普通方式 –</summary>
</entry>
<entry>
<title>使用MySQL遇到的坑</title>
<link href="/%E4%BD%BF%E7%94%A8MySQL%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" rel="alternate" type="text/html" title="使用MySQL遇到的坑" />
<published>2016-07-13T00:00:00+08:00</published>
<updated>2016-07-13T00:00:00+08:00</updated>
<id>/使用MySQL遇到的坑</id>
<content type="html" xml:base="/%E4%BD%BF%E7%94%A8MySQL%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">&lt;p&gt;遇到一些错误：&lt;/p&gt;

&lt;p&gt;```
 ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password:YES)&lt;/p&gt;

&lt;p&gt;ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password:NO)
```&lt;/p&gt;

&lt;p&gt;查看当前用户&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
 mysql&amp;gt; select current_user();
 +----------------+
 | current_user() |
 +----------------+
 | root@localhost |
 +----------------+
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面是用户没有创建或没有权限，所以创建一个新用户：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mysql -uroot -p 登录mysql&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建一个新用户&lt;/p&gt;

&lt;p&gt;```
 mysql&amp;gt; CREATE USER ‘wei’@’localhost’ IDENTIFIED BY ‘123’;&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; grant all privileges on &lt;em&gt;.&lt;/em&gt; to wei@localhost identified by ‘123’;
 Query OK, 0 rows affected (0.00 sec)
 mysql&amp;gt; flush privileges;
 Query OK, 0 rows affected (0.00 sec)
```&lt;/p&gt;

&lt;p&gt;查看用户&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
 mysql&amp;gt; select user, host from mysql.user;
 +------+---------------------------+
 | user | host                      |
 +------+---------------------------+
 | root | 127.0.0.1                 |
 | root | ::1                       |
 | wei  | host                      |
 |      | localhost                 |
 | root | localhost                 |
 | wei  | localhost                 |
 |      | tindledemacbook-pro.local |
 | root | tindledemacbook-pro.local |
 +------+---------------------------+
 8 rows in set (0.00 sec)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;再登录&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ mysql -uwei -p123&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lioncode/article/details/7917310&quot;&gt;参考博客1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;python-&quot;&gt;另外Python错误 端口占用问题&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;socket.error: [Errno 48] Address already in use &lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原因&lt;/h3&gt;

&lt;p&gt;其实就是因为你曾启动过相同或者类似的服务占用了这个端口，一般来讲，在Mac上直接用Python启动的话，会导致退出不完整，你不能通过点击GUI的“退出”按钮来一步到位，后台的Python进程还是存在的，而它就是一直占用端口不释放的元凶。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo lsof -i:8087&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用以显示符合条件的进程情况&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo kill *pid* &lt;/code&gt; //对应进程的PID&lt;/p&gt;

&lt;h2 id=&quot;pycharm&quot;&gt;Pycharm&lt;/h2&gt;

&lt;p&gt;这软件简直和Android Studio一模一样啊！&lt;/p&gt;

&lt;p&gt;纪录一些快捷键:&lt;/p&gt;

&lt;p&gt;Command + Alt + L 代码格式化&lt;/p&gt;

&lt;p&gt;Command + Alt + I 自动缩进&lt;/p&gt;

&lt;p&gt;Command + Alt + O 优化导入&lt;/p&gt;

&lt;p&gt;Command + Tab 窗口间切换&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.2cto.com/os/201410/341542.html&quot;&gt;参考网址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;macmysqlerror-2002-hy000-cant-connect-to-local-mysql-server-through-socket-tmpmysqlsock&quot;&gt;Mac上MySQL报错：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动 &lt;code&gt;mysql.server start&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;登录 &lt;code&gt;mysql -uwei -pxxx&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000094608&quot;&gt;参考网址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;mysqlserver-starterror-the-server-quit-without-updating-pid-file-usrlocalvarmysqltindledemacbook-prolocalpid&quot;&gt;mysql.server start报错：ERROR! The server quit without updating PID file (/usr/local/var/mysql/tindledeMacBook-Pro.local.pid).&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;sudo lsof -i:3306&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;sudo kill *pid* &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
<summary>遇到一些错误：``` ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password:YES)ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password:NO)```</summary>
</entry>
<entry>
<title>写个RxBus</title>
<link href="/%E5%86%99%E4%B8%AARxBus/" rel="alternate" type="text/html" title="写个RxBus" />
<published>2016-07-12T00:00:00+08:00</published>
<updated>2016-07-12T00:00:00+08:00</updated>
<id>/写个RxBus</id>
<content type="html" xml:base="/%E5%86%99%E4%B8%AARxBus/">&lt;h3 id=&quot;rxbus&quot;&gt;RxBus单例&lt;/h3&gt;

&lt;p&gt;```java
public class RxBus {
    private static volatile RxBus instance = null;
    /**
     * PublishSubject只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者
     */
    private Subject&amp;lt;Object, Object&amp;gt; bus = new SerializedSubject&amp;lt;&amp;gt;(PublishSubject.create());&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static RxBus getDefault() {
    if(instance == null){
        synchronized (RxBus.class) {
            if (instance == null) {
                instance = new RxBus();
            }
        }
    }
    return instance;
}

public void post(Object o) {
    bus.onNext(o);
}

public Observable&amp;lt;Object&amp;gt; toObserverable() {
    return bus;
}

/**
 * 判断是否有订阅者
 */
public boolean hasObservers() {
    return bus.hasObservers();
} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;发事件&lt;/h3&gt;

&lt;p&gt;```java
	RxBus.getDefault().send(new TapEvent());&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;收事件&lt;/h3&gt;

&lt;p&gt;```java
	_subscriptions = new CompositeSubscription();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ConnectableObservable&amp;lt;Object&amp;gt; tapEventEmitter = _rxBus.toObserverable().publish();

_subscriptions
   .add(tapEventEmitter.subscribe(new Action1&amp;lt;Object&amp;gt;() {
              &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
              public void call(Object event) {
                  if (event instanceof TapEvent) {
                     // here we come
                  }
              }
          })); ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简写成：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
	_subscriptions
       .add(_rxBus.toObserverable().subscribe(new Action1&amp;lt;Object&amp;gt;() {
                  &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
                  public void call(Object event) {
                      if (event instanceof TapEvent) {
                         // here we come
                      }
                  }
              }));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kaushikgopal/RxJava-Android-Samples&quot;&gt;参考RxJava-Android-Samples&lt;/a&gt;&lt;/p&gt;
</content>
<summary>RxBus单例</summary>
</entry>
<entry>
<title>写个Java单例</title>
<link href="/%E5%86%99%E4%B8%AAJava%E5%8D%95%E4%BE%8B/" rel="alternate" type="text/html" title="写个Java单例" />
<published>2016-07-12T00:00:00+08:00</published>
<updated>2016-07-12T00:00:00+08:00</updated>
<id>/写个Java单例</id>
<content type="html" xml:base="/%E5%86%99%E4%B8%AAJava%E5%8D%95%E4%BE%8B/">&lt;h3 id=&quot;section&quot;&gt;一个比较好的的单例：&lt;/h3&gt;

&lt;p&gt;```
private static volatile SettingsDbHelper sInst = null;  // «&amp;lt; 这里添加了 volatile&lt;br /&gt;
public static SettingsDbHelper getInstance(Context context) {&lt;br /&gt;
    SettingsDbHelper inst = sInst;  // «&amp;lt; 在这里创建临时变量
    if (inst == null) {
        synchronized (SettingsDbHelper.class) {
            inst = sInst;
            if (inst == null) {
                inst = new SettingsDbHelper(context);
                sInst = inst;
            }
        }
    }
    return inst;  // «&amp;lt; 注意这里返回的是临时变量
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;为什么用 volatile？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对 volatile 变量的写操作，不允许和它之前的读写操作打乱顺序；对 volatile 变量的读操作，不允许和它之后的读写乱序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;dl&gt;
  &lt;dt&gt;为什么需要再定义一个临时变量 inst？&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;访问 volatile 变量，需要保证一些执行顺序，所以的开销比较大。&lt;br /&gt;
通过这样修改以后，在运行过程中，除了第一次以外，其他的调用只要访问 volatile 变量 sInst 一次，这样能提高 25% 的性能（Wikipedia）。&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;h3 id=&quot;section-1&quot;&gt;补充，另一个比较好的懒加载单例：&lt;/h3&gt;

&lt;p&gt;它能够延迟初始化（lazy initialization），并且多线程安全，还能保证高性能.&lt;/p&gt;

&lt;p&gt;```
class Foo {&lt;br /&gt;
    private static class HelperHolder {
       public static final Helper helper = new Helper();
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Helper getHelper() {
    return HelperHolder.helper;
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java&quot;&gt;Double-checked locking机制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.race604.com/java-double-checked-singleton/&quot;&gt;这篇文章更详细参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/java-memory-model-1&quot;&gt;深入理解Java内存模型&lt;/a&gt;&lt;/p&gt;
</content>
<summary>一个比较好的的单例：</summary>
</entry>
<entry>
<title>Android Color</title>
<link href="/How%20to%20make%20wonderful%20CardView/" rel="alternate" type="text/html" title="Android Color" />
<published>2016-07-06T00:00:00+08:00</published>
<updated>2016-07-06T00:00:00+08:00</updated>
<id>/How to make wonderful CardView</id>
<content type="html" xml:base="/How%20to%20make%20wonderful%20CardView/">&lt;h1 id=&quot;how-to-make-wonderful-cardview&quot;&gt;How To Make Wonderful CardView&lt;/h1&gt;

&lt;div align=&quot;center&quot;&gt;    
How to make view like this ?
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../img/blog_16_6_17_1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;    
Wonderful, isn&#39;t it?
&lt;/div&gt;

&lt;p&gt;我们这就来说说 CardView：&lt;/p&gt;

</content>
</entry>
<entry>
<title>Android color</title>
<link href="/Android%20Color/" rel="alternate" type="text/html" title="Android color" />
<published>2016-07-04T00:00:00+08:00</published>
<updated>2016-07-04T00:00:00+08:00</updated>
<id>/Android Color</id>
<content type="html" xml:base="/Android%20Color/">&lt;h2 id=&quot;section&quot;&gt;```&lt;/h2&gt;
&lt;p&gt;layout: post
title:  Android Color 
date:   2016-06-15 
categories: Android
excerpt: 
—
```&lt;/p&gt;

&lt;h1 id=&quot;gson-user-guide&quot;&gt;Gson User Guide&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#TOC-Overview&quot;&gt;Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#TOC-Goals-for-Gson&quot;&gt;Goals for Gson&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Gson-Performance-and-Scalability&quot;&gt;Gson Performance and Scalability&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Gson-Users&quot;&gt;Gson Users&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Using-Gson&quot;&gt;Using Gson&lt;/a&gt;
  	* &lt;a href=&quot;#TOC-Gson-With-Maven&quot;&gt;Using Gson with Maven&lt;/a&gt;
  	* &lt;a href=&quot;#TOC-Primitives-Examples&quot;&gt;Primitives Examples&lt;/a&gt;
  	* &lt;a href=&quot;#TOC-Object-Examples&quot;&gt;Object Examples&lt;/a&gt;
  	* &lt;a href=&quot;#TOC-Finer-Points-with-Objects&quot;&gt;Finer Points with Objects&lt;/a&gt;
  	* &lt;a href=&quot;#TOC-Nested-Classes-including-Inner-Classes-&quot;&gt;Nested Classes (including Inner Classes)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Array-Examples&quot;&gt;Array Examples&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Collections-Examples&quot;&gt;Collections Examples&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Collections-Limitations&quot;&gt;Collections Limitations&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Serializing-and-Deserializing-Generic-Types&quot;&gt;Serializing and Deserializing Generic Types&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types&quot;&gt;Serializing and Deserializing Collection with Objects of Arbitrary Types&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Built-in-Serializers-and-Deserializers&quot;&gt;Built-in Serializers and Deserializers&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Custom-Serialization-and-Deserialization&quot;&gt;Custom Serialization and Deserialization&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Writing-a-Serializer&quot;&gt;Writing a Serializer&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Writing-a-Deserializer&quot;&gt;Writing a Deserializer&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Writing-an-Instance-Creator&quot;&gt;Writing an Instance Creator&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-InstanceCreator-for-a-Parameterized-Type&quot;&gt;InstanceCreator for a Parameterized Type&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format&quot;&gt;Compact Vs. Pretty Printing for JSON Output Format&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Null-Object-Support&quot;&gt;Null Object Support&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Versioning-Support&quot;&gt;Versioning Support&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Excluding-Fields-From-Serialization-and-Deserialization&quot;&gt;Excluding Fields From Serialization and Deserialization&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Java-Modifier-Exclusion&quot;&gt;Java Modifier Exclusion&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Gson-s-Expose&quot;&gt;Gson’s &lt;code&gt;&amp;lt;a href=&#39;https://github.com/Expose&#39; class=&#39;user-mention&#39;&amp;gt;@Expose&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-User-Defined-Exclusion-Strategies&quot;&gt;User Defined Exclusion Strategies&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-JSON-Field-Naming-Support&quot;&gt;JSON Field Naming Support&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers&quot;&gt;Sharing State Across Custom Serializers and Deserializers&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#TOC-Streaming&quot;&gt;Streaming&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#TOC-Issues-in-Designing-Gson&quot;&gt;Issues in Designing Gson&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#TOC-Future-Enhancements-to-Gson&quot;&gt;Future Enhancements to Gson&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;a-nametoc-overviewaoverview&quot;&gt;&lt;a name=&quot;TOC-Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;

&lt;p&gt;Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.&lt;/p&gt;

&lt;p&gt;Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.&lt;/p&gt;

&lt;h2 id=&quot;a-nametoc-goals-for-gsonagoals-for-gson&quot;&gt;&lt;a name=&quot;TOC-Goals-for-Gson&quot;&gt;&lt;/a&gt;Goals for Gson&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Provide easy to use mechanisms like &lt;code&gt;toString()&lt;/code&gt; and constructor (factory method) to convert Java to JSON and vice-versa&lt;/li&gt;
  &lt;li&gt;Allow pre-existing unmodifiable objects to be converted to and from JSON&lt;/li&gt;
  &lt;li&gt;Allow custom representations for objects&lt;/li&gt;
  &lt;li&gt;Support arbitrarily complex objects&lt;/li&gt;
  &lt;li&gt;Generate compact and readable JSON output&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;a-nametoc-gson-performance-and-scalabilityagson-performance-and-scalability&quot;&gt;&lt;a name=&quot;TOC-Gson-Performance-and-Scalability&quot;&gt;&lt;/a&gt;Gson Performance and Scalability&lt;/h2&gt;

&lt;p&gt;Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class &lt;a href=&quot;gson/src/test/java/com/google/gson/metrics/PerformanceTest.java&quot;&gt;&lt;code&gt;PerformanceTest&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Strings: Deserialized strings of over 25MB without any problems (see &lt;code&gt;disabled_testStringDeserializationPerformance&lt;/code&gt; method in &lt;code&gt;PerformanceTest&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Large collections:
    &lt;ul&gt;
      &lt;li&gt;Serialized a collection of 1.4 million objects (see &lt;code&gt;disabled_testLargeCollectionSerialization&lt;/code&gt; method in &lt;code&gt;PerformanceTest&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;Deserialized a collection of 87,000 objects (see &lt;code&gt;disabled_testLargeCollectionDeserialization&lt;/code&gt; in &lt;code&gt;PerformanceTest&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: Delete the &lt;code&gt;disabled_&lt;/code&gt; prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.&lt;/p&gt;

&lt;h2 id=&quot;a-nametoc-gson-usersagson-users&quot;&gt;&lt;a name=&quot;TOC-Gson-Users&quot;&gt;&lt;/a&gt;Gson Users&lt;/h2&gt;

&lt;p&gt;Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details &lt;a href=&quot;https://sites.google.com/site/gson/gson-users&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-nametoc-using-gsonausing-gson&quot;&gt;&lt;a name=&quot;TOC-Using-Gson&quot;&gt;&lt;/a&gt;Using Gson&lt;/h2&gt;

&lt;p&gt;The primary class to use is &lt;a href=&quot;gson/src/main/java/com/google/gson/Gson.java&quot;&gt;&lt;code&gt;Gson&lt;/code&gt;&lt;/a&gt; which you can just create by calling &lt;code&gt;new Gson()&lt;/code&gt;. There is also a class &lt;a href=&quot;gson/src/main/java/com/google/gson/GsonBuilder.java&quot;&gt;&lt;code&gt;GsonBuilder&lt;/code&gt;&lt;/a&gt; available that can be used to create a Gson instance with various settings like version control and so on.&lt;/p&gt;

&lt;p&gt;The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.&lt;/p&gt;

&lt;h2 id=&quot;a-nametoc-gson-with-mavenausing-gson-with-maven&quot;&gt;&lt;a name=&quot;TOC-Gson-With-Maven&quot;&gt;&lt;/a&gt;Using Gson with Maven&lt;/h2&gt;
&lt;p&gt;To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:&lt;/p&gt;

&lt;p&gt;```xml&lt;/p&gt;
&lt;dependencies&gt;
    &lt;!--  Gson: Java to Json conversion --&gt;
    &lt;dependency&gt;
      &lt;groupid&gt;com.google.code.gson&lt;/groupid&gt;
      &lt;artifactid&gt;gson&lt;/artifactid&gt;
      &lt;version&gt;2.7&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;That is it, now your maven project is Gson enabled.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-primitives-examplesaprimitives-examples&quot;&gt;&lt;a name=&quot;TOC-Primitives-Examples&quot;&gt;&lt;/a&gt;Primitives Examples&lt;/h3&gt;

&lt;p&gt;```java
// Serialization
Gson gson = new Gson();
gson.toJson(1);            // ==&amp;gt; 1
gson.toJson(“abcd”);       // ==&amp;gt; “abcd”
gson.toJson(new Long(10)); // ==&amp;gt; 10
int[] values = { 1 };
gson.toJson(values);       // ==&amp;gt; [1]&lt;/p&gt;

&lt;p&gt;// Deserialization
int one = gson.fromJson(“1”, int.class);
Integer one = gson.fromJson(“1”, Integer.class);
Long one = gson.fromJson(“1”, Long.class);
Boolean false = gson.fromJson(“false”, Boolean.class);
String str = gson.fromJson(“&quot;abc&quot;”, String.class);
String[] anotherStr = gson.fromJson(“[&quot;abc&quot;]”, String[].class);
```&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-object-examplesaobject-examples&quot;&gt;&lt;a name=&quot;TOC-Object-Examples&quot;&gt;&lt;/a&gt;Object Examples&lt;/h3&gt;

&lt;p&gt;```java
class BagOfPrimitives {
  private int value1 = 1;
  private String value2 = “abc”;
  private transient int value3 = 3;
  BagOfPrimitives() {
    // no-args constructor
  }
}&lt;/p&gt;

&lt;p&gt;// Serialization
BagOfPrimitives obj = new BagOfPrimitives();
Gson gson = new Gson();
String json = gson.toJson(obj);&lt;/p&gt;

&lt;p&gt;// ==&amp;gt; json is {“value1”:1,”value2”:”abc”}
```&lt;/p&gt;

&lt;p&gt;Note that you can not serialize objects with circular references since that will result in infinite recursion.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
// Deserialization
BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);
// ==&amp;gt; obj2 is just like obj
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-finer-points-with-objectsafiner-points-with-objects&quot;&gt;&lt;a name=&quot;TOC-Finer-Points-with-Objects&quot;&gt;&lt;/a&gt;&lt;strong&gt;Finer Points with Objects&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;It is perfectly fine (and recommended) to use private fields&lt;/li&gt;
  &lt;li&gt;There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.&lt;/li&gt;
  &lt;li&gt;If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.&lt;/li&gt;
  &lt;li&gt;This implementation handles nulls correctly&lt;/li&gt;
  &lt;li&gt;While serializing, a null field is skipped from the output&lt;/li&gt;
  &lt;li&gt;While deserializing, a missing entry in JSON results in setting the corresponding field in the object to null&lt;/li&gt;
  &lt;li&gt;If a field is &lt;em&gt;synthetic&lt;/em&gt;, it is ignored and not included in JSON serialization or deserialization&lt;/li&gt;
  &lt;li&gt;Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-nametoc-nested-classes-including-inner-classes-anested-classes-including-inner-classes&quot;&gt;&lt;a name=&quot;TOC-Nested-Classes-including-Inner-Classes-&quot;&gt;&lt;/a&gt;Nested Classes (including Inner Classes)&lt;/h3&gt;

&lt;p&gt;Gson can serialize static nested classes quite easily.&lt;/p&gt;

&lt;p&gt;Gson can also deserialize static nested classes. However, Gson can &lt;strong&gt;not&lt;/strong&gt; automatically deserialize the &lt;strong&gt;pure inner classes since their no-args constructor also need a reference to the containing Object&lt;/strong&gt; which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:&lt;/p&gt;

&lt;p&gt;```java
public class A { 
  public String a;&lt;/p&gt;

&lt;p&gt;class B {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String b; 

public B() {
  // No args constructor for B
}   }  } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The above class B can not (by default) be serialized with Gson.&lt;/p&gt;

&lt;p&gt;Gson can not deserialize &lt;code&gt;{&quot;b&quot;:&quot;abc&quot;}&lt;/code&gt; into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
public class InstanceCreatorForB implements InstanceCreator&amp;lt;A.B&amp;gt; {
  private final A a;
  public InstanceCreatorForB(A a)  {
    this.a = a;
  }
  public A.B createInstance(Type type) {
    return a.new B();
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above is possible, but not recommended.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-array-examplesaarray-examples&quot;&gt;&lt;a name=&quot;TOC-Array-Examples&quot;&gt;&lt;/a&gt;Array Examples&lt;/h3&gt;

&lt;p&gt;```java
Gson gson = new Gson();
int[] ints = {1, 2, 3, 4, 5};
String[] strings = {“abc”, “def”, “ghi”};&lt;/p&gt;

&lt;p&gt;// Serialization
gson.toJson(ints);     // ==&amp;gt; [1,2,3,4,5]
gson.toJson(strings);  // ==&amp;gt; [“abc”, “def”, “ghi”]&lt;/p&gt;

&lt;p&gt;// Deserialization
int[] ints2 = gson.fromJson(“[1,2,3,4,5]”, int[].class); 
// ==&amp;gt; ints2 will be same as ints
```&lt;/p&gt;

&lt;p&gt;We also support multi-dimensional arrays, with arbitrarily complex element types.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-collections-examplesacollections-examples&quot;&gt;&lt;a name=&quot;TOC-Collections-Examples&quot;&gt;&lt;/a&gt;Collections Examples&lt;/h3&gt;

&lt;p&gt;```java
Gson gson = new Gson();
Collection&lt;integer&gt; ints = Lists.immutableList(1,2,3,4,5);&lt;/integer&gt;&lt;/p&gt;

&lt;p&gt;// Serialization
String json = gson.toJson(ints);  // ==&amp;gt; json is [1,2,3,4,5]&lt;/p&gt;

&lt;p&gt;// Deserialization
Type collectionType = new TypeToken&amp;lt;Collection&lt;integer&gt;&amp;gt;(){}.getType();
Collection&lt;integer&gt; ints2 = gson.fromJson(json, collectionType);
// ==&amp;gt; ints2 is same as ints
```&lt;/integer&gt;&lt;/integer&gt;&lt;/p&gt;

&lt;p&gt;Fairly hideous: note how we define the type of collection.
Unfortunately, there is no way to get around this in Java.&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-collections-limitationsacollections-limitations&quot;&gt;&lt;a name=&quot;TOC-Collections-Limitations&quot;&gt;&lt;/a&gt;Collections Limitations&lt;/h4&gt;

&lt;p&gt;Gson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type.
This makes sense, and is rarely a problem when following good Java coding practices.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-serializing-and-deserializing-generic-typesaserializing-and-deserializing-generic-types&quot;&gt;&lt;a name=&quot;TOC-Serializing-and-Deserializing-Generic-Types&quot;&gt;&lt;/a&gt;Serializing and Deserializing Generic Types&lt;/h3&gt;

&lt;p&gt;When you call &lt;code&gt;toJson(obj)&lt;/code&gt;, Gson calls &lt;code&gt;obj.getClass()&lt;/code&gt; to get information on the fields to serialize. Similarly, you can typically pass &lt;code&gt;MyClass.class&lt;/code&gt; object in the &lt;code&gt;fromJson(json, MyClass.class)&lt;/code&gt; method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:&lt;/p&gt;

&lt;p&gt;```java
class Foo&lt;t&gt; {
  T value;
}
Gson gson = new Gson();
Foo&lt;bar&gt; foo = new Foo&lt;bar&gt;();
gson.toJson(foo); // May not serialize foo.value correctly&lt;/bar&gt;&lt;/bar&gt;&lt;/t&gt;&lt;/p&gt;

&lt;p&gt;gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
```&lt;/p&gt;

&lt;p&gt;The above code fails to interpret value as type Bar because Gson invokes &lt;code&gt;list.getClass()&lt;/code&gt; to get its class information, but this method returns a raw class, &lt;code&gt;Foo.class&lt;/code&gt;. This means that Gson has no way of knowing that this is an object of type &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt;, and not just plain &lt;code&gt;Foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the &lt;a href=&quot;http://google.github.io/gson/apidocs/com/google/gson/reflect/TypeToken.html&quot;&gt;&lt;code&gt;TypeToken&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;p&gt;```java
Type fooType = new TypeToken&amp;lt;Foo&lt;bar&gt;&amp;gt;() {}.getType();
gson.toJson(foo, fooType);&lt;/bar&gt;&lt;/p&gt;

&lt;p&gt;gson.fromJson(json, fooType);
```
The idiom used to get &lt;code&gt;fooType&lt;/code&gt; actually defines an anonymous local inner class containing a method &lt;code&gt;getType()&lt;/code&gt; that returns the fully parameterized type.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-serializing-and-deserializing-collection-with-objects-of-arbitrary-typesaserializing-and-deserializing-collection-with-objects-of-arbitrary-types&quot;&gt;&lt;a name=&quot;TOC-Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types&quot;&gt;&lt;/a&gt;Serializing and Deserializing Collection with Objects of Arbitrary Types&lt;/h3&gt;

&lt;p&gt;Sometimes you are dealing with JSON array that contains mixed types. For example:
&lt;code&gt;[&#39;hello&#39;,5,{name:&#39;GREETINGS&#39;,source:&#39;guest&#39;}]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The equivalent &lt;code&gt;Collection&lt;/code&gt; containing this is:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
Collection collection = new ArrayList();
collection.add(&quot;hello&quot;);
collection.add(5);
collection.add(new Event(&quot;GREETINGS&quot;, &quot;guest&quot;));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;where the &lt;code&gt;Event&lt;/code&gt; class is defined as:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
class Event {
  private String name;
  private String source;
  private Event(String name, String source) {
    this.name = name;
    this.source = source;
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can serialize the collection with Gson without doing anything specific: &lt;code&gt;toJson(collection)&lt;/code&gt; would write out the desired output.&lt;/p&gt;

&lt;p&gt;However, deserialization with &lt;code&gt;fromJson(json, Collection.class)&lt;/code&gt; will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in &lt;code&gt;fromJson()&lt;/code&gt;. So, you have three options:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Use Gson’s parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use &lt;code&gt;Gson.fromJson()&lt;/code&gt; on each of the array elements.This is the preferred approach. &lt;a href=&quot;extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java&quot;&gt;Here is an example&lt;/a&gt; that demonstrates how to do this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Register a type adapter for &lt;code&gt;Collection.class&lt;/code&gt; that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Register a type adapter for &lt;code&gt;MyCollectionMemberType&lt;/code&gt; and use &lt;code&gt;fromJson()&lt;/code&gt; with &lt;code&gt;Collection&amp;lt;MyCollectionMemberType&amp;gt;&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type &lt;code&gt;Collection&amp;lt;MyCollectionMemberType&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-built-in-serializers-and-deserializersabuilt-in-serializers-and-deserializers&quot;&gt;&lt;a name=&quot;TOC-Built-in-Serializers-and-Deserializers&quot;&gt;&lt;/a&gt;Built-in Serializers and Deserializers&lt;/h3&gt;

&lt;p&gt;Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate.
Here is a list of such classes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;java.net.URL&lt;/code&gt; to match it with strings like &lt;code&gt;&quot;https://github.com/google/gson/&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;java.net.URI&lt;/code&gt; to match it with strings like &lt;code&gt;&quot;/google/gson/&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can also find source code for some commonly used classes such as JodaTime at &lt;a href=&quot;https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-custom-serialization-and-deserializationacustom-serialization-and-deserialization&quot;&gt;&lt;a name=&quot;TOC-Custom-Serialization-and-Deserialization&quot;&gt;&lt;/a&gt;Custom Serialization and Deserialization&lt;/h3&gt;

&lt;p&gt;Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc).
Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Json Serializers: Need to define custom serialization for an object&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Json Deserializers: Needed to define custom deserialization for a type&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Instance Creators: Not needed if no-args constructor is available or a deserializer is registered&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;java
GsonBuilder gson = new GsonBuilder();
gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());
gson.registerTypeAdapter(MyType.class, new MySerializer());
gson.registerTypeAdapter(MyType.class, new MyDeserializer());
gson.registerTypeAdapter(MyType.class, new MyInstanceCreator());
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;registerTypeAdapter&lt;/code&gt; call checks if the type adapter implements more than one of these interfaces and register it for all of them.&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-writing-a-serializerawriting-a-serializer&quot;&gt;&lt;a name=&quot;TOC-Writing-a-Serializer&quot;&gt;&lt;/a&gt;Writing a Serializer&lt;/h4&gt;

&lt;p&gt;Here is an example of how to write a custom serializer for JodaTime &lt;code&gt;DateTime&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
private class DateTimeSerializer implements JsonSerializer&amp;lt;DateTime&amp;gt; {
  public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) {
    return new JsonPrimitive(src.toString());
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Gson calls &lt;code&gt;serialize()&lt;/code&gt; when it runs into a &lt;code&gt;DateTime&lt;/code&gt; object during serialization.&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-writing-a-deserializerawriting-a-deserializer&quot;&gt;&lt;a name=&quot;TOC-Writing-a-Deserializer&quot;&gt;&lt;/a&gt;Writing a Deserializer&lt;/h4&gt;

&lt;p&gt;Here is an example of how to write a custom deserializer for JodaTime DateTime class.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
private class DateTimeDeserializer implements JsonDeserializer&amp;lt;DateTime&amp;gt; {
  public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
      throws JsonParseException {
    return new DateTime(json.getAsJsonPrimitive().getAsString());
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Gson calls &lt;code&gt;deserialize&lt;/code&gt; when it needs to deserialize a JSON string fragment into a DateTime object&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Finer points with Serializers and Deserializers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Often you want to register a single handler for all generic types corresponding to a raw type&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For example, suppose you have an &lt;code&gt;Id&lt;/code&gt; class for id representation/translation (i.e. an internal vs. external representation).&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Id&amp;lt;T&amp;gt;&lt;/code&gt; type that has same serialization for all generic types
    &lt;ul&gt;
      &lt;li&gt;Essentially write out the id value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deserialization is very similar but not exactly the same
    &lt;ul&gt;
      &lt;li&gt;Need to call &lt;code&gt;new Id(Class&amp;lt;T&amp;gt;, String)&lt;/code&gt; which returns an instance of &lt;code&gt;Id&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say &lt;code&gt;Id&amp;lt;RequiresSpecialHandling&amp;gt;&lt;/code&gt; needed special handling).
The &lt;code&gt;Type&lt;/code&gt; parameter for the &lt;code&gt;toJson()&lt;/code&gt; and &lt;code&gt;fromJson()&lt;/code&gt; contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-writing-an-instance-creatorawriting-an-instance-creator&quot;&gt;&lt;a name=&quot;TOC-Writing-an-Instance-Creator&quot;&gt;&lt;/a&gt;Writing an Instance Creator&lt;/h3&gt;

&lt;p&gt;While deserializing an Object, Gson needs to create a default instance of the class.
Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Doesn’t matter whether public or private&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Instance Creator Example&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
private class MoneyInstanceCreator implements InstanceCreator&amp;lt;Money&amp;gt; {
  public Money createInstance(Type type) {
    return new Money(&quot;1000000&quot;, CurrencyCode.USD);
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Type could be of a corresponding generic type&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Very useful to invoke constructors which need specific generic type information&lt;/li&gt;
  &lt;li&gt;For example, if the &lt;code&gt;Id&lt;/code&gt; class stores the class for which the Id is being created&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;a-nametoc-instancecreator-for-a-parameterized-typeainstancecreator-for-a-parameterized-type&quot;&gt;&lt;a name=&quot;TOC-InstanceCreator-for-a-Parameterized-Type&quot;&gt;&lt;/a&gt;InstanceCreator for a Parameterized Type&lt;/h4&gt;

&lt;p&gt;Sometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:&lt;/p&gt;

&lt;p&gt;```java
class MyList&lt;t&gt; extends ArrayList&lt;t&gt; {
}&lt;/t&gt;&lt;/t&gt;&lt;/p&gt;

&lt;p&gt;class MyListInstanceCreator implements InstanceCreator&amp;lt;MyList&lt;?&gt;&gt; {
    &lt;a href=&#39;https://github.com/SuppressWarnings&#39; class=&#39;user-mention&#39;&gt;@SuppressWarnings&lt;/a&gt;(&quot;unchecked&quot;)
  public MyList&lt;?&gt; createInstance(Type type) {
    // No need to use a parameterized list since the actual instance will have the raw type anyway.
    return new MyList();
  }
}
```&lt;/p&gt;

&lt;p&gt;However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the &lt;code&gt;createInstance&lt;/code&gt; method. Here is an example:&lt;/p&gt;

&lt;p&gt;```java
public class Id&lt;t&gt; {
  private final Class&lt;t&gt; classOfId;
  private final long value;
  public Id(Class&lt;t&gt; classOfId, long value) {
    this.classOfId = classOfId;
    this.value = value;
  }
}&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/p&gt;

&lt;p&gt;class IdInstanceCreator implements InstanceCreator&amp;lt;Id&lt;?&gt;&gt; {
  public Id&lt;?&gt; createInstance(Type type) {
    Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments();
    Type idType = typeParameters[0]; // Id has only one parameterized type T
    return Id.get((Class)idType, 0L);
  }
}
```&lt;/p&gt;

&lt;p&gt;In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, &lt;code&gt;type&lt;/code&gt;. The &lt;code&gt;type&lt;/code&gt; object in this case is the Java parameterized type representation of &lt;code&gt;Id&amp;lt;Foo&amp;gt;&lt;/code&gt; where the actual instance should be bound to &lt;code&gt;Id&amp;lt;Foo&amp;gt;&lt;/code&gt;. Since &lt;code&gt;Id&lt;/code&gt; class has just one parameterized type parameter, &lt;code&gt;T&lt;/code&gt;, we use the zeroth element of the type array returned by &lt;code&gt;getActualTypeArgument()&lt;/code&gt; which will hold &lt;code&gt;Foo.class&lt;/code&gt; in this case.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-compact-vs-pretty-printing-for-json-output-formatacompact-vs-pretty-printing-for-json-output-format&quot;&gt;&lt;a name=&quot;TOC-Compact-Vs.-Pretty-Printing-for-JSON-Output-Format&quot;&gt;&lt;/a&gt;Compact Vs. Pretty Printing for JSON Output Format&lt;/h3&gt;

&lt;p&gt;The default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, “null” fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the &lt;a href=&quot;#TOC-Null-Object-Support&quot;&gt;Null Object Support&lt;/a&gt; section for information on configure Gson to output all null values.&lt;/p&gt;

&lt;p&gt;If you would like to use the Pretty Print feature, you must configure your &lt;code&gt;Gson&lt;/code&gt; instance using the &lt;code&gt;GsonBuilder&lt;/code&gt;. The &lt;code&gt;JsonFormatter&lt;/code&gt; is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default &lt;code&gt;JsonPrintFormatter&lt;/code&gt; that has default line length of 80 character, 2 character indentation, and 4 character right margin.&lt;/p&gt;

&lt;p&gt;The following is an example shows how to configure a &lt;code&gt;Gson&lt;/code&gt; instance to use the default &lt;code&gt;JsonPrintFormatter&lt;/code&gt; instead of the &lt;code&gt;JsonCompactFormatter&lt;/code&gt;:
&lt;code&gt;
Gson gson = new GsonBuilder().setPrettyPrinting().create();
String jsonOutput = gson.toJson(someObject);
&lt;/code&gt;
### &lt;a name=&quot;TOC-Null-Object-Support&quot;&gt;&lt;/a&gt;Null Object Support&lt;/p&gt;

&lt;p&gt;The default behaviour that is implemented in Gson is that &lt;code&gt;null&lt;/code&gt; object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.&lt;/p&gt;

&lt;p&gt;Here’s how you would configure a &lt;code&gt;Gson&lt;/code&gt; instance to output null:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
Gson gson = new GsonBuilder().serializeNulls().create();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;NOTE: when serializing &lt;code&gt;null&lt;/code&gt;s with Gson, it will add a &lt;code&gt;JsonNull&lt;/code&gt; element to the &lt;code&gt;JsonElement&lt;/code&gt; structure. Therefore, this object can be used in custom serialization/deserialization.&lt;/p&gt;

&lt;p&gt;Here’s an example:&lt;/p&gt;

&lt;p&gt;```java
public class Foo {
  private final String s;
  private final int i;&lt;/p&gt;

&lt;p&gt;public Foo() {
    this(null, 5);
  }&lt;/p&gt;

&lt;p&gt;public Foo(String s, int i) {
    this.s = s;
    this.i = i;
  }
}&lt;/p&gt;

&lt;p&gt;Gson gson = new GsonBuilder().serializeNulls().create();
Foo foo = new Foo();
String json = gson.toJson(foo);
System.out.println(json);&lt;/p&gt;

&lt;p&gt;json = gson.toJson(null);
System.out.println(json);
```&lt;/p&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{&quot;s&quot;:null,&quot;i&quot;:5}
null
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-versioning-supportaversioning-support&quot;&gt;&lt;a name=&quot;TOC-Versioning-Support&quot;&gt;&lt;/a&gt;Versioning Support&lt;/h3&gt;

&lt;p&gt;Multiple versions of the same object can be maintained by using &lt;a href=&quot;gson/src/main/java/com/google/gson/annotations/Since.java&quot;&gt;&lt;a href=&quot;https://github.com/Since&quot; class=&quot;user-mention&quot;&gt;@Since&lt;/a&gt;&lt;/a&gt; annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your &lt;code&gt;Gson&lt;/code&gt; instance to ignore any field/object that is greater than some version number. If no version is set on the &lt;code&gt;Gson&lt;/code&gt; instance then it will serialize and deserialize all fields and classes regardless of the version.&lt;/p&gt;

&lt;p&gt;```java
public class VersionedClass {
  &lt;a href=&quot;https://github.com/Since&quot; class=&quot;user-mention&quot;&gt;@Since&lt;/a&gt;(1.1) private final String newerField;
  &lt;a href=&quot;https://github.com/Since&quot; class=&quot;user-mention&quot;&gt;@Since&lt;/a&gt;(1.0) private final String newField;
  private final String field;&lt;/p&gt;

&lt;p&gt;public VersionedClass() {
    this.newerField = “newer”;
    this.newField = “new”;
    this.field = “old”;
  }
}&lt;/p&gt;

&lt;p&gt;VersionedClass versionedObject = new VersionedClass();
Gson gson = new GsonBuilder().setVersion(1.0).create();
String jsonOutput = gson.toJson(someObject);
System.out.println(jsonOutput);
System.out.println();&lt;/p&gt;

&lt;p&gt;gson = new Gson();
jsonOutput = gson.toJson(someObject);
System.out.println(jsonOutput);
```&lt;/p&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;p&gt;```
{“newField”:”new”,”field”:”old”}&lt;/p&gt;

&lt;p&gt;{“newerField”:”newer”,”newField”:”new”,”field”:”old”}
```&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-excluding-fields-from-serialization-and-deserializationaexcluding-fields-from-serialization-and-deserialization&quot;&gt;&lt;a name=&quot;TOC-Excluding-Fields-From-Serialization-and-Deserialization&quot;&gt;&lt;/a&gt;Excluding Fields From Serialization and Deserialization&lt;/h3&gt;

&lt;p&gt;Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use &lt;a href=&quot;#TOC-Custom-Serialization-and-Deserialization&quot;&gt;custom serializers and deserializers&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-java-modifier-exclusionajava-modifier-exclusion&quot;&gt;&lt;a name=&quot;TOC-Java-Modifier-Exclusion&quot;&gt;&lt;/a&gt;Java Modifier Exclusion&lt;/h4&gt;

&lt;p&gt;By default, if you mark a field as &lt;code&gt;transient&lt;/code&gt;, it will be excluded. As well, if a field is marked as &lt;code&gt;static&lt;/code&gt; then by default it will be excluded. If you want to include some transient fields then you can do the following:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
import java.lang.reflect.Modifier;
Gson gson = new GsonBuilder()
    .excludeFieldsWithModifiers(Modifier.STATIC)
    .create();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;NOTE: you can give any number of the &lt;code&gt;Modifier&lt;/code&gt; constants to the &lt;code&gt;excludeFieldsWithModifiers&lt;/code&gt; method. For example:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java
Gson gson = new GsonBuilder()
    .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE)
    .create();
&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-gson-s-exposeagsons-a-hrefhttpsgithubcomexpose-classuser-mentionexposea&quot;&gt;&lt;a name=&quot;TOC-Gson-s-Expose&quot;&gt;&lt;/a&gt;Gson’s &lt;code&gt;&amp;lt;a href=&#39;https://github.com/Expose&#39; class=&#39;user-mention&#39;&amp;gt;@Expose&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using &lt;code&gt;new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()&lt;/code&gt;. The Gson instance created will exclude all fields in a class that are not marked with &lt;code&gt;&amp;lt;a href=&#39;https://github.com/Expose&#39; class=&#39;user-mention&#39;&amp;gt;@Expose&amp;lt;/a&amp;gt;&lt;/code&gt; annotation.&lt;/p&gt;

&lt;h4 id=&quot;a-nametoc-user-defined-exclusion-strategiesauser-defined-exclusion-strategies&quot;&gt;&lt;a name=&quot;TOC-User-Defined-Exclusion-Strategies&quot;&gt;&lt;/a&gt;User Defined Exclusion Strategies&lt;/h4&gt;

&lt;p&gt;If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the &lt;a href=&quot;http://google.github.io/gson/apidocs/com/google/gson/ExclusionStrategy.html&quot;&gt;&lt;code&gt;ExclusionStrategy&lt;/code&gt;&lt;/a&gt; JavaDoc for more information.&lt;/p&gt;

&lt;p&gt;The following example shows how to exclude fields marked with a specific &lt;code&gt;&amp;lt;a href=&#39;https://github.com/Foo&#39; class=&#39;user-mention&#39;&amp;gt;@Foo&amp;lt;/a&amp;gt;&lt;/code&gt; annotation and excludes top-level types (or declared field type) of class &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;```java
&lt;a href=&quot;https://github.com/Retention&quot; class=&quot;user-mention&quot;&gt;@Retention&lt;/a&gt;(RetentionPolicy.RUNTIME)
&lt;a href=&quot;https://github.com/Target&quot; class=&quot;user-mention&quot;&gt;@Target&lt;/a&gt;({ElementType.FIELD})
public &lt;a href=&quot;https://github.com/interface&quot; class=&quot;user-mention&quot;&gt;@interface&lt;/a&gt; Foo {
  // Field tag only annotation
}&lt;/p&gt;

&lt;p&gt;public class SampleObjectForTest {
  &lt;a href=&quot;https://github.com/Foo&quot; class=&quot;user-mention&quot;&gt;@Foo&lt;/a&gt; private final int annotatedField;
  private final String stringField;
  private final long longField;
  private final Class&amp;lt;?&amp;gt; clazzField;&lt;/p&gt;

&lt;p&gt;public SampleObjectForTest() {
    annotatedField = 5;
    stringField = “someDefaultValue”;
    longField = 1234;
  }
}&lt;/p&gt;

&lt;p&gt;public class MyExclusionStrategy implements ExclusionStrategy {
  private final Class&amp;lt;?&amp;gt; typeToSkip;&lt;/p&gt;

&lt;p&gt;private MyExclusionStrategy(Class&amp;lt;?&amp;gt; typeToSkip) {
    this.typeToSkip = typeToSkip;
  }&lt;/p&gt;

&lt;p&gt;public boolean shouldSkipClass(Class&amp;lt;?&amp;gt; clazz) {
    return (clazz == typeToSkip);
  }&lt;/p&gt;

&lt;p&gt;public boolean shouldSkipField(FieldAttributes f) {
    return f.getAnnotation(Foo.class) != null;
  }
}&lt;/p&gt;

&lt;p&gt;public static void main(String[] args) {
  Gson gson = new GsonBuilder()
      .setExclusionStrategies(new MyExclusionStrategy(String.class))
      .serializeNulls()
      .create();
  SampleObjectForTest src = new SampleObjectForTest();
  String json = gson.toJson(src);
  System.out.println(json);
}
```&lt;/p&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{&quot;longField&quot;:1234}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-json-field-naming-supportajson-field-naming-support&quot;&gt;&lt;a name=&quot;TOC-JSON-Field-Naming-Support&quot;&gt;&lt;/a&gt;JSON Field Naming Support&lt;/h3&gt;

&lt;p&gt;Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case — &lt;code&gt;sampleFieldNameInJava&lt;/code&gt;) to a Json field name (i.e., &lt;code&gt;sample_field_name_in_java&lt;/code&gt; or &lt;code&gt;SampleFieldNameInJava&lt;/code&gt;). See the &lt;a href=&quot;http://google.github.io/gson/apidocs/com/google/gson/FieldNamingPolicy.html&quot;&gt;FieldNamingPolicy&lt;/a&gt; class for information on the pre-defined naming policies.&lt;/p&gt;

&lt;p&gt;It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise “Runtime” exceptions if an invalid field name is provided as the annotation value.&lt;/p&gt;

&lt;p&gt;The following is an example of how to use both Gson naming policy features:&lt;/p&gt;

&lt;p&gt;```java
private class SomeObject {
  &lt;a href=&quot;https://github.com/SerializedName&quot; class=&quot;user-mention&quot;&gt;@SerializedName&lt;/a&gt;(“custom_naming”) private final String someField;
  private final String someOtherField;&lt;/p&gt;

&lt;p&gt;public SomeObject(String a, String b) {
    this.someField = a;
    this.someOtherField = b;
  }
}&lt;/p&gt;

&lt;p&gt;SomeObject someObject = new SomeObject(“first”, “second”);
Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();
String jsonRepresentation = gson.toJson(someObject);
System.out.println(jsonRepresentation);
```&lt;/p&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{&quot;custom_naming&quot;:&quot;first&quot;,&quot;SomeOtherField&quot;:&quot;second&quot;}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you have a need for custom naming policy (&lt;a href=&quot;http://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892&quot;&gt;see this discussion&lt;/a&gt;), you can use the &lt;a href=&quot;http://google.github.io/gson/apidocs/com/google/gson/annotations/SerializedName.html&quot;&gt;&lt;a href=&quot;https://github.com/SerializedName&quot; class=&quot;user-mention&quot;&gt;@SerializedName&lt;/a&gt;&lt;/a&gt; annotation.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-sharing-state-across-custom-serializers-and-deserializersasharing-state-across-custom-serializers-and-deserializers&quot;&gt;&lt;a name=&quot;TOC-Sharing-State-Across-Custom-Serializers-and-Deserializers&quot;&gt;&lt;/a&gt;Sharing State Across Custom Serializers and Deserializers&lt;/h3&gt;

&lt;p&gt;Sometimes you need to share state across custom serializers/deserializers (&lt;a href=&quot;http://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb&quot;&gt;see this discussion&lt;/a&gt;). You can use the following three strategies to accomplish this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Store shared state in static fields&lt;/li&gt;
  &lt;li&gt;Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state&lt;/li&gt;
  &lt;li&gt;Use Java &lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1 and 2 are not thread-safe options, but 3 is.&lt;/p&gt;

&lt;h3 id=&quot;a-nametoc-streamingastreaming&quot;&gt;&lt;a name=&quot;TOC-Streaming&quot;&gt;&lt;/a&gt;Streaming&lt;/h3&gt;

&lt;p&gt;In addition Gson’s object model and data binding, you can use Gson to read from and write to a &lt;a href=&quot;https://sites.google.com/site/gson/streaming&quot;&gt;stream&lt;/a&gt;. You can also combine streaming and object model access to get the best of both approaches.&lt;/p&gt;

&lt;h2 id=&quot;a-nametoc-issues-in-designing-gsonaissues-in-designing-gson&quot;&gt;&lt;a name=&quot;TOC-Issues-in-Designing-Gson&quot;&gt;&lt;/a&gt;Issues in Designing Gson&lt;/h2&gt;

&lt;p&gt;See the &lt;a href=&quot;https://sites.google.com/site/gson/gson-design-document&quot; title=&quot;Gson design document&quot;&gt;Gson design document&lt;/a&gt; for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.&lt;/p&gt;

&lt;h2 id=&quot;a-nametoc-future-enhancements-to-gsonafuture-enhancements-to-gson&quot;&gt;&lt;a name=&quot;TOC-Future-Enhancements-to-Gson&quot;&gt;&lt;/a&gt;Future Enhancements to Gson&lt;/h2&gt;

&lt;p&gt;For the latest list of proposed enhancements or if you’d like to suggest new ones, see the &lt;a href=&quot;https://github.com/google/gson/issues&quot;&gt;Issues section&lt;/a&gt; under the project website.&lt;/p&gt;

&lt;h2 id=&quot;shader&quot;&gt;Shader&lt;/h2&gt;

&lt;h2 id=&quot;colorfilter&quot;&gt;ColorFilter&lt;/h2&gt;

&lt;h2 id=&quot;maskfilter&quot;&gt;MaskFilter&lt;/h2&gt;

</content>
<summary>```layout: posttitle:  Android Color date:   2016-06-15 categories: Androidexcerpt: —```</summary>
</entry>
<entry>
<title>RxJava一些概念的理解</title>
<link href="/RxJava%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3/" rel="alternate" type="text/html" title="RxJava一些概念的理解" />
<published>2016-06-15T00:00:00+08:00</published>
<updated>2016-06-15T00:00:00+08:00</updated>
<id>/RxJava一些概念的理解</id>
<content type="html" xml:base="/RxJava%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3/">&lt;p&gt;RxJava一些概念的理解 
(摘录自soaringEveryday的博客)&lt;/p&gt;

&lt;p&gt;api/students/getAll (传入班级的id获得班级的学生数组，返回值是list)
api/courses/getAll (传入Student的id获得这个学生所上的课程，返回值是List)&lt;/p&gt;

&lt;p&gt;使用Volley是下面这样子：&lt;/p&gt;

&lt;p&gt;```
private void getAllStudents(String id) {
        BaseRequest baseRequest = new BaseRequest();
        baseRequest.setClassId(id);
        String url = AppConfig.SERVER_URL + “api/students/getAll”;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    final GsonRequest request = new GsonRequest&amp;lt;&amp;gt;(url, baseRequest, Response.class, new Response.Listener&amp;lt;response&amp;gt;() {
        &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
        public void onResponse(Response response) {
            if (response.getStatus() &amp;gt; 0) {
                List&amp;lt;student&amp;gt; studentList = response.getData();
                for (Student student : studentList) {

                }
            } else {
                //error
            }
        }
    }, new Response.ErrorListener() {
        &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
        public void onErrorResponse(VolleyError error) {
            //error
        }
    });
    MyVolley.startRequest(request);
}

private void getAllCourses(String id) {
    BaseRequest baseRequest = new BaseRequest();
    baseRequest.setStudentId(id);
    String url = AppConfig.SERVER_URL + &quot;api/courses/getAll&quot;;

    final GsonRequest request = new GsonRequest&amp;lt;&amp;gt;(url, baseRequest, Response.class, new Response.Listener&amp;lt;response&amp;gt;() {
        &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
        public void onResponse(Response response) {
            if (response.getStatus() &amp;gt; 0) {
                List&amp;lt;course&amp;gt; courseList = response.getData();
                for (Course course : courseList) {
                    //use
                }
            } else {
                //error
            }
        }
    }, new Response.ErrorListener() {
        &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
        public void onErrorResponse(VolleyError error) {
            //error
        }
    });
    MyVolley.startRequest(request);
} ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用RxJava是下面这样：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
ConnectionBase.getApiService2()
                .getStudents(101)
                .flatMap(new Func1&amp;lt;student, observable&amp;lt;course=&quot;&quot;&amp;gt;&amp;gt;() {
                    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
                    public Observable&amp;lt;course&amp;gt; call(Student student) {
                        return ConnectionBase.getApiService2().getAllCourse(student.getId());
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1&amp;lt;course&amp;gt;() {
                    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
                    public void call(Course course) {
                        //use the Course
                    }
                });
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先getStudent传入了班级id(101)返回了Observable，然后链式调用flatMap操作符对这个Observable进行变换处理，针对每一个发射出来的Student进行再次请求 ConnectionBase.getApiService2().getAllCourse从而返回Observable，最后对这个 ConnectionBase.getApiService2().getAllCourse进行订阅，即subscribe方法，再Action1这个闭包的回调中使用course。&lt;/p&gt;

&lt;p&gt;flatMap的作用就是对传入的对象进行处理，返回下一级所要的对象的Observable包装。&lt;/p&gt;

&lt;p&gt;FuncX和ActionX的区别。FuncX包装的是有返回值的方法，用于Observable的变换、组合等等；ActionX用于包装无返回值的方法，用于subscribe方法的闭包参数。Func1有两个入参，前者是原始的参数类型，后者是返回值类型；而Action1只有一个入参，就是传入的被消费的数据类型。&lt;/p&gt;

&lt;p&gt;subscribeOn(Schedulers.io()).observeOn(AndroidScheduler.mainThread())是最常用的方式，后台读取数据，主线程更新界面。subScribeOn指在哪个线程发射数据，observeOn是指在哪里消费数据。由于最终的Course要刷新界面，必须要在主线程上调用更新view的方法，所以observeOn(AndroidScheduler.mainThread())是至关重要的。&lt;/p&gt;

&lt;h1 id=&quot;map--flatmap&quot;&gt;map &amp;amp; flatMap&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;
ConnectionBase.getApiService2()
                .getStudents(101)
                .map(new Func1&amp;lt;student, Course&amp;gt;() {
                    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
                    public Course call(Student student) {
                        return conventStudentToCourse();// has problem
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1&amp;lt;course&amp;gt;() {
                    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
                    public void call(Course course) {
                        //use the Course
                    }
                });
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到map也是接受一个Func1闭包，但是这个闭包的第二个参数即返回值参数类型并不是一个被包装的Observable，而是实际的原始类型，由于call的返回值是Course，所以conventStudentToCourse这里就不能用Retrofit2的方式返回一个Observable了。&lt;/p&gt;

&lt;p&gt;所以这里是有一个问题的，对于这种嵌套的网络请求，由于接到上端数据流到处理后将结果数据放入下端数据流是一个异步的过程，而conventStudentToCourse这种直接将Student转化为Course是没法做到异步的，因为没有回调方法。那么这种情况，最好还是用flatMap并通过retrofit的方式来获取Observable。要知道，Rxjava的一个精髓就是“异步”.&lt;/p&gt;

&lt;p&gt;那么到底map和flatMap有什么区别，或者说什么时候使用map什么时候使用flatMap呢？
flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。&lt;/p&gt;

&lt;p&gt;首先，如果你需要将一个类型的对象经过处理（非异步）直接转化成下一个类型，推荐用map，否则的话就用flatMap。
其次，如果你需要在处理中加入容错的机制（特别是你自己封装基于RxJava的网络请求框架），推荐用flatMap。&lt;/p&gt;

&lt;p&gt;flapMap写法的好处&lt;/p&gt;

&lt;p&gt;比如将一个File[] jsonFile中每个File转换成String，用map的话代码为：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Observable.from(jsonFile).map(new Func1&amp;lt;file, string=&quot;&quot;&amp;gt;() {
    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt; public String call(File file) {
        try {
            return new Gson().toJson(new FileReader(file), Object.class);
        } catch (FileNotFoundException e) {
            // So Exception. What to do ?
        }
        return null; // Not good :(
    }
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到这里在出现错误的时候直接抛出异常，这样的处理其实并不好，特别如果你自己封装框架，这个异常不大好去抓取。&lt;/p&gt;

&lt;p&gt;如果用flatMap，由于flatMap的闭包返回值是一个Observable，所以我们可以在这个闭包的call中通过Observable.create的方式来创建Observable，而要知道create方法是可以控制数据流下端的Subscriber的，即可以调用onNext/onCompete/onError方法。如果出现异常，我们直接调用subscribe.onError即可，封装框架也很好感知。代码大致如下：&lt;/p&gt;

&lt;p&gt;```
Observable.from(jsonFile).flatMap(new Func1&amp;lt;file, observable&amp;lt;string=””»() {
    &lt;a href=&quot;https://github.com/Override&quot; class=&quot;user-mention&quot;&gt;@Override&lt;/a&gt; public Observable&lt;string&gt; call(final File file) {
        return Observable.create(new Observable.OnSubscribe&lt;string&gt;() {
            &lt;a href=&quot;https://github.com/Override&quot; class=&quot;user-mention&quot;&gt;@Override&lt;/a&gt; public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber) {
                try {
                    String json = new Gson().toJson(new FileReader(file), Object.class);&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                subscriber.onNext(json);
                subscriber.onCompleted();
            } catch (FileNotFoundException e) {
                subscriber.onError(e);
            }
        }
    });
} }); ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map操作符通常也用于处理结构化的服务端响应数据，比如下列返回的JSON数据就是一段典型的响应数据&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
{
    &quot;message&quot;:&quot;操作成功&quot;,
    &quot;status&quot;:1,
    &quot;data&quot;:
    {
        &quot;noVisitCount&quot;:0,
        &quot;planCount&quot;:0,
        &quot;visitedCount&quot;:0
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在map的闭包中，我们可以先判断status进行统一的出错或者正确（返回data的内容）处理，一般来说，data的内容都是处理成一个泛型&lt;/p&gt;

</content>
</entry>
<entry>
<title>关于Android graphics的Camera和Matrix</title>
<link href="/Android%20graphics%E7%9A%84Camera%E5%92%8CMatrix/" rel="alternate" type="text/html" title="关于Android graphics的Camera和Matrix" />
<published>2016-03-10T00:00:00+08:00</published>
<updated>2016-03-10T00:00:00+08:00</updated>
<id>/Android graphics的Camera和Matrix</id>
<content type="html" xml:base="/Android%20graphics%E7%9A%84Camera%E5%92%8CMatrix/">&lt;h2 id=&quot;android-graphicscameramatrix&quot;&gt;关于Android graphics的Camera和Matrix&lt;/h2&gt;

&lt;h3 id=&quot;camera&quot;&gt;Camera&lt;/h3&gt;

&lt;p&gt;这是camera类的主要方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public native void save();
public native void restore();
public native void translate(float x, float y, float z);
public native void rotateX(float deg);
public native void rotateY(float deg);
public native void rotateZ(float deg);
public native void rotate(float x, float y, float z);
public native float getLocationX();
public native float getLocationY();
public native float getLocationZ();
public native void setLocation(float x, float y, float z);
public void getMatrix(Matrix matrix) {
    nativeGetMatrix(matrix.native_instance);
}
public void applyToCanvas(Canvas canvas) {
    nativeApplyToCanvas(canvas.mNativeCanvas);
}
public native float dotWithNormal(float dx, float dy, float dz);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是Camera变换的坐标轴
&lt;img src=&quot;/img/image-src.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在rotate的时候，要站在该轴正方向的地方看，才能明白他的旋转。
如 camera.rotateZ(-60)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/20120929085945172.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;matrix&quot;&gt;Matrix&lt;/h3&gt;

&lt;p&gt;Matrix是一个3 x 3的2D空间矩阵&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/tindle/Desktop/1349614431_7130.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MPERSP_2指的是投影变换,其实际作用就是如果MPERSP_2=0.5，那么物体是原来的4倍大小；如果MPERSP_2=2，那么物体是原来的1/4大小。&lt;/p&gt;

&lt;p&gt;Camera和Matrix的联合使用：一般情况下，如果我们需要进行3D变换，那么需要将Camera和Matrix联合使用，使用Camera进行x轴或y轴的旋转，使用Matrix进行平移或放大。&lt;/p&gt;
</content>
</entry>
<entry>
<title>关于RxJava的使用</title>
<link href="/%E5%85%B3%E4%BA%8ERxJava%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="alternate" type="text/html" title="关于RxJava的使用" />
<published>2016-03-05T00:00:00+08:00</published>
<updated>2016-03-05T00:00:00+08:00</updated>
<id>/关于RxJava的使用</id>
<content type="html" xml:base="/%E5%85%B3%E4%BA%8ERxJava%E7%9A%84%E4%BD%BF%E7%94%A8/">&lt;p&gt;RxJava 的观察者模式
RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。&lt;/p&gt;

&lt;p&gt;与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。&lt;/p&gt;

&lt;p&gt;1) 创建 Observer&lt;br /&gt;
Observer 即观察者&lt;/p&gt;

&lt;p&gt;Observer&lt;string&gt; observer = new Observer&lt;string&gt;() {
    &lt;a href=&quot;https://github.com/Override&quot; class=&quot;user-mention&quot;&gt;@Override&lt;/a&gt;
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}
 
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subscriber&lt;string&gt; subscriber = new Subscriber&lt;string&gt;() {
    &lt;a href=&quot;https://github.com/Override&quot; class=&quot;user-mention&quot;&gt;@Override&lt;/a&gt;
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }&lt;/string&gt;&lt;/string&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void onCompleted() {
    Log.d(tag, &quot;Completed!&quot;);
}
 
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void onError(Throwable e) {
    Log.d(tag, &quot;Error!&quot;);
}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们的基本使用方式是完全一样的&lt;/p&gt;

&lt;p&gt;2) 创建 Observable&lt;br /&gt;
Observable 即被观察者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Observable observable = Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void call(Subscriber&amp;lt;? super String&amp;gt; subscriber) {
    subscriber.onNext(&quot;Hello&quot;);
    subscriber.onNext(&quot;Hi&quot;);
    subscriber.onNext(&quot;Aloha&quot;);
    subscriber.onCompleted();
}});

Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();

String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面 just(T…) 的例子和 from(T[]) 的例子，都和之前的 create(OnSubscribe) 的例子是等价的。&lt;/p&gt;

&lt;p&gt;3) Subscribe (订阅)&lt;br /&gt;
创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable.subscribe(observer);
// 或者：
observable.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出Subscriber：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Action1&amp;lt;String&amp;gt; onNextAction = new Action1&amp;lt;String&amp;gt;() {
// onNext()
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void call(String s) {
    Log.d(tag, s);
}
};
Action1&amp;lt;Throwable&amp;gt; onErrorAction = new Action1&amp;lt;Throwable&amp;gt;() {
// onError()
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void call(Throwable throwable) {
    // Error handling
}
};
Action0 onCompletedAction = new Action0() {
// onCompleted()
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void call() {
    Log.d(tag, &quot;completed&quot;);
}
};
 
// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 	onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 	onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, 	onCompletedAction);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程控制 —— Scheduler&lt;/p&gt;

&lt;p&gt;subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。
observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Observable.just(1, 2, 3, 4)
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Action1&amp;lt;Integer&amp;gt;() {
    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
    public void call(Integer number) {
        Log.d(tag, &quot;number:&quot; + number);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;变换&lt;/h3&gt;

&lt;p&gt;map(): 事件对象的直接变换，它是 RxJava 最常用的变换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
.map(new Func1&amp;lt;String, Bitmap&amp;gt;() {
    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
    public Bitmap call(String filePath) { // 参数类型 String
        return getBitmapFromPath(filePath); // 返回类型 Bitmap
    }
})
.subscribe(new Action1&amp;lt;Bitmap&amp;gt;() {
    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
    public void call(Bitmap bitmap) { // 参数类型 Bitmap
        showBitmap(bitmap);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map() 是一对一的转化，而我现在的要求是一对多的转化, 就需要用 flatMap()了.&lt;/p&gt;

 	Student[] students = …;
&lt;pre&gt;&lt;code&gt;Subscriber&amp;lt;Course&amp;gt; subscriber = new Subscriber&amp;lt;Course&amp;gt;() {
&amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
public void onNext(Course course) {
    Log.d(tag, course.getName());
}
...
};
Observable.from(students)
.flatMap(new Func1&amp;lt;Student, Observable&amp;lt;Course&amp;gt;&amp;gt;() {
    &amp;lt;a href=&#39;https://github.com/Override&#39; class=&#39;user-mention&#39;&amp;gt;@Override&amp;lt;/a&amp;gt;
    public Observable&amp;lt;Course&amp;gt; call(Student student) {
        return Observable.from(student.getCourses());
    }
})
.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。通过 observeOn() 的多次调用，程序实现了线程的多次切换.&lt;/p&gt;

 	Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
&lt;pre&gt;&lt;code&gt;.subscribeOn(Schedulers.io())
.observeOn(Schedulers.newThread())
.map(mapOperator) // 新线程，由 observeOn() 指定
.observeOn(Schedulers.io())
.map(mapOperator2) // IO 线程，由 observeOn() 指定
.observeOn(AndroidSchedulers.mainThread) 
.subscribe(subscriber);  // Android 主线程，由 observeOn() 指定
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;至此，结束。&lt;/p&gt;
</content>
<summary>RxJava 的观察者模式</summary>
</entry>
</feed>
